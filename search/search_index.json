{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenue sur le projet TER","text":""},{"location":"#sections","title":"Sections","text":"<ul> <li>Documentations</li> <li>Journal de bord</li> </ul>"},{"location":"docs/boot_sequence/","title":"Processus de Boot","text":""},{"location":"docs/boot_sequence/#introduction","title":"Introduction","text":"<p>Le processus de boot d'un syst\u00e8me embarqu\u00e9 sur la Zybo Z7-20 est structur\u00e9 en plusieurs \u00e9tapes. Cette organisation en \u00e9tapes est essentielle pour g\u00e9rer la complexit\u00e9 du d\u00e9marrage, l'initialisation progressive des composants mat\u00e9riels, et la configuration logicielle. Voici une explication de chaque \u00e9tape et pourquoi elles sont n\u00e9cessaires.</p>"},{"location":"docs/boot_sequence/#les-etapes-du-processus-de-boot","title":"Les \u00c9tapes du Processus de Boot","text":"<pre><code>graph TD;\n    A[FSBL] --&gt; B[U-Boot]\n    B --&gt; C[Linux Kernel]\n    C --&gt; D[Root File System]\n    E[Device Tree] --&gt; C\n    D --&gt; F[User Space]</code></pre>"},{"location":"docs/boot_sequence/#1-first-stage-bootloader","title":"1. First Stage Bootloader","text":"<p>Le FSBL est le premier programme \u00e0 s'ex\u00e9cuter apr\u00e8s la mise sous tension du syst\u00e8me.  Il est stock\u00e9 dans la m\u00e9moire non volatile (NOR flash, QSPI flash) et ses principales fonctions sont d'initialiser les composants mat\u00e9riels de base comme la m\u00e9moire DDR et les p\u00e9riph\u00e9riques critiques, puis de charger et transf\u00e9rer le contr\u00f4le au Second Stage Bootloader.</p> <p>Pourquoi utiliser un FSBL ?</p> <p>Historiquement, une version all\u00e9g\u00e9e d'U-Boot suffisait pour programmer la m\u00e9moire flash car elle tenait dans la m\u00e9moire OCM. Avec l'ajout de la prise en charge de nouvelles familles de flash, la taille d'U-Boot a augment\u00e9, n\u00e9cessitant l'utilisation de la m\u00e9moire DDR pour son ex\u00e9cution. Le FSBL est donc n\u00e9cessaire pour initialiser la m\u00e9moire DDR et autres modules avant de charger U-Boot (xilinx support).</p>"},{"location":"docs/boot_sequence/#2-universal-bootloader","title":"2. Universal Bootloader","text":"<p>U-Boot (Das U-Boot) est un bootloader open-source de deuxi\u00e8me niveau utilis\u00e9 par de nombreuses plateformes embarqu\u00e9es. Il est responsable des t\u00e2ches plus complexes. Ses fonctions incluent :</p> <ul> <li>Initialiser les p\u00e9riph\u00e9riques mat\u00e9riels suppl\u00e9mentaires non g\u00e9r\u00e9s par le FSBL.</li> <li>Charger le noyau Linux en m\u00e9moire.</li> <li>Charger le Device Tree Blob (DTB) et le Root File System (RFS).</li> <li>Fournir une interface pour des configurations suppl\u00e9mentaires et le d\u00e9bogage.</li> </ul> <p>Pour plus d'informations</p> <p>Consultez le site officiel de U-Boot et le d\u00e9p\u00f4t GitHub de U-Boot.</p>"},{"location":"docs/boot_sequence/#3-linux-kernel","title":"3. Linux Kernel","text":"<p>Le noyau Linux est le c\u0153ur du syst\u00e8me d'exploitation, responsable de la gestion des ressources mat\u00e9rielles et de l'ex\u00e9cution des processus. Une fois charg\u00e9 par U-Boot, il effectue plusieurs op\u00e9rations critiques :</p> <ul> <li>Initialisation du mat\u00e9riel : Le noyau utilise les informations fournies par le Device Tree pour configurer et initialiser les p\u00e9riph\u00e9riques mat\u00e9riels du syst\u00e8me.</li> <li>Montage du Root File System : Le noyau monte le syst\u00e8me de fichiers racine, qui contient tous les fichiers n\u00e9cessaires pour le fonctionnement du syst\u00e8me d'exploitation.</li> <li>Lancement du processus initial (init) : Le noyau d\u00e9marre le processus init, qui est le premier processus utilisateur lanc\u00e9 par le noyau et qui reste en cours d'ex\u00e9cution jusqu'\u00e0 l'arr\u00eat du syst\u00e8me. Ce processus init initialise les autres processus et services du syst\u00e8me.</li> </ul> <p>Pour plus d'informations</p> <p>Pour plus d'informations et pour approfondir vos connaissances sur le noyau Linux, consultez les ressources suivantes :</p> <ul> <li>Documentation officielle du noyau Linux</li> <li>R\u00e9f\u00e9rentiel GitHub du noyau Linux</li> </ul>"},{"location":"docs/boot_sequence/#4-device-tree","title":"4. Device Tree","text":"<p>Le Device Tree est une structure qui d\u00e9crit le mat\u00e9riel pr\u00e9sent sur la carte. Il fournit au noyau Linux les informations n\u00e9cessaires pour initialiser et g\u00e9rer les p\u00e9riph\u00e9riques mat\u00e9riels.</p> <p>Pourquoi utiliser un Device Tree ?</p> <p>Le Device Tree permet de maintenir le noyau Linux g\u00e9n\u00e9rique, sans avoir besoin de coder des d\u00e9tails mat\u00e9riels sp\u00e9cifiques dans le noyau lui-m\u00eame. Cela permet de porter le m\u00eame noyau sur diff\u00e9rentes plateformes mat\u00e9rielles, simplement en modifiant le Device Tree. Cette flexibilit\u00e9 est cruciale pour le d\u00e9veloppement et la maintenance de syst\u00e8mes embarqu\u00e9s.</p> <p>Exemple de Device Tree</p> <pre><code>{\n  \"compatible\": \"digilent,zybo-z7\",\n  \"model\": \"Digilent Zybo Z7\",\n  \"memory\": {\n    \"device_type\": \"memory\",\n    \"reg\": \"0x10000000\"\n  },\n  \"cpus\": {\n    \"cpu@0\": {\n      \"device_type\": \"cpu\",\n      \"compatible\": \"arm,cortex-a9\"\n    }\n  }\n}\n</code></pre> <p>Vous pouvez vous r\u00e9f\u00e9rer \u00e0 la Les Devices Tree pour en savoir plus sur la structure et la g\u00e9n\u00e9ration des fichiers Device Tree et Device Tree Overlay (DTO).</p>"},{"location":"docs/boot_sequence/#5-root-file-system","title":"5. Root File System","text":"<p>Le RFS fournit le contexte et les ressources n\u00e9cessaires au noyau Linux pour ex\u00e9cuter des applications et des services. Sans un syst\u00e8me de fichiers mont\u00e9, le noyau ne peut pas acc\u00e9der aux fichiers et aux commandes n\u00e9cessaires pour d\u00e9marrer le syst\u00e8me et ex\u00e9cuter des t\u00e2ches.</p> <p>Le RFS inclut g\u00e9n\u00e9ralement :</p> <ul> <li>Biblioth\u00e8ques partag\u00e9es : Fichiers n\u00e9cessaires pour le fonctionnement des applications.</li> <li>Utilitaires syst\u00e8me : Commandes et programmes essentiels comme <code>bash</code>, <code>ls</code>, <code>cp</code>, etc.</li> <li>Fichiers de configuration : Param\u00e8tres de configuration pour les services et les applications.</li> <li>Applications : Programmes n\u00e9cessaires au fonctionnement de l'utilisateur et du syst\u00e8me.</li> </ul> <p>Options pour obtenir un RFS</p> <ul> <li>T\u00e9l\u00e9chargez un RFS pr\u00e9-construit depuis une source fiable, comme RCN-EE.</li> <li>Utiliser un Outil de construction tel que Buildroot ou Yocto pour g\u00e9n\u00e9rer un RFS personnalis\u00e9.</li> </ul>"},{"location":"docs/boot_sequence/#6-user-space","title":"6. User Space","text":"<p>L'User Space est l'environnement dans lequel s'ex\u00e9cutent les applications et les services utilisateurs. Apr\u00e8s le montage du RFS et le lancement du processus initial, le contr\u00f4le passe \u00e0 l'espace utilisateur.</p> <p>Le User Space permet aux utilisateurs et aux applications de fonctionner ind\u00e9pendamment du noyau. Cela isole les processus utilisateurs des op\u00e9rations critiques du noyau. Le User Space comprend toutes les applications, biblioth\u00e8ques et services n\u00e9cessaires pour que le syst\u00e8me soit fonctionnel et interactif.</p>"},{"location":"docs/boot_sequence/#table-recapitulative","title":"Table r\u00e9capitulative","text":"Composant Fonction principale FSBL Initialiser le mat\u00e9riel de base et charger U-Boot U-Boot Initialiser des p\u00e9riph\u00e9riques suppl\u00e9mentaires, charger le noyau Linux, le Device Tree et le RFS Linux Kernel Initialiser le mat\u00e9riel, monter le RFS et lancer le processus initial Device Tree D\u00e9crire le mat\u00e9riel pour le noyau Linux Root File System Contenir tous les fichiers n\u00e9cessaires pour le syst\u00e8me d'exploitation User Space Environnement pour l'ex\u00e9cution des applications et services utilisateurs"},{"location":"docs/device_tree/","title":"Device Tree et Device Tree Overlay","text":""},{"location":"docs/device_tree/#introduction","title":"Introduction","text":"<p>Le Device Tree permet de maintenir le noyau Linux g\u00e9n\u00e9rique, sans avoir besoin d'int\u00e9grer des d\u00e9tails mat\u00e9riels sp\u00e9cifiques dans le noyau lui-m\u00eame. Cette flexibilit\u00e9 permet de porter le m\u00eame noyau sur diff\u00e9rentes plateformes mat\u00e9rielles en modifiant simplement le Device Tree. Cette caract\u00e9ristique est cruciale pour le d\u00e9veloppement et la maintenance de syst\u00e8mes embarqu\u00e9s.</p>"},{"location":"docs/device_tree/#device-tree","title":"Device Tree","text":"<p>Les Device Trees permettent de visualiser les diff\u00e9rents p\u00e9riph\u00e9riques, composants et registres accessibles par le processeur sous forme d'une structure arborescente. Cette approche organise les informations de mani\u00e8re hi\u00e9rarchique, facilitant ainsi l'identification et l'acc\u00e8s aux composants sp\u00e9cifiques du syst\u00e8me.</p> <p>La syntaxe utilis\u00e9e pour d\u00e9finir les Device Trees est la suivante (elinux.org) :</p> <p>Exemple de Device Tree</p> <pre><code>/dts-v1/;\n\n/ {\n    node1 {\n        a-string-property = \"A string\";\n        a-string-list-property = \"first string\", \"second string\";\n        // hex is implied in byte arrays. no '0x' prefix is required\n        a-byte-data-property = [01 23 34 56];\n        child-node1 {\n            first-child-property;\n            second-child-property = &lt;1&gt;;\n            a-string-property = \"Hello, world\";\n        };\n        child-node2 {\n        };\n    };\n    node2 {\n        an-empty-property;\n        a-cell-property = &lt;1 2 3 4&gt;; /* each number (cell) is a uint32 */\n        child-node1 {\n        };\n    };\n};\n</code></pre> <p>Les Device Trees doivent \u00eatre compil\u00e9s pour \u00eatre transform\u00e9s en un format binaire utilisable par le syst\u00e8me. Cette \u00e9tape de compilation est effectu\u00e9e \u00e0 l'aide de l'outil Device Tree Compiler (DTC). Le r\u00e9sultat de cette compilation est un Device Tree Blob (DTB) sous l'extension <code>.dtb</code>.</p> <p>Plus de d\u00e9tails concernant les Device Trees sont disponibles sur Device Tree 101, une pr\u00e9sentation de Bootlin.</p> <p>S\u00e9paration des fichiers</p> <p>Il est souvent n\u00e9cessaire de s\u00e9parer un Device Tree en plusieurs fichiers. Cette s\u00e9paration se fait en utilisant les formats suivants :</p> <ul> <li><code>.dts</code> (Device Tree Source) : fichier principal du Device Tree, pouvant inclure d'autres fichiers.</li> <li><code>.dtsi</code> (Device Tree Include) : fichiers \u00e0 inclure dans le fichier principal .dts via des directives #include.</li> </ul> <p>L'assemblage de ces fichiers s\u00e9par\u00e9s est r\u00e9alis\u00e9 en utilisant le pr\u00e9processeur GCC, permettant ainsi de combiner les diff\u00e9rentes parties en un seul fichier coh\u00e9rent (fichier <code>.dts</code> final sans #include).</p>"},{"location":"docs/device_tree/#device-tree-overlay","title":"Device Tree Overlay","text":"<p>Les Device Trees d\u00e9crivent les composants mat\u00e9riels pour que le syst\u00e8me d'exploitation puisse les reconna\u00eetre et les utiliser. Cependant, que faire si l'on veut ajouter un composant alors qu'un Device Tree est d\u00e9j\u00e0 en cours d'utilisation et qu'il est impossible d'\u00e9teindre le syst\u00e8me ? </p> <p>La solution se trouve dans les Device Tree Overlays (DTO). Ces morceaux de Device Tree permettent de rajouter, modifier ou m\u00eame supprimer des n\u0153uds de l'arbre, modifiant ainsi le comportement du syst\u00e8me \u00e0 la vol\u00e9e.</p> <p>Les fichiers de DTO sont g\u00e9n\u00e9ralement au format <code>.dtso</code> et <code>.dtbo</code> pour la version compil\u00e9e. Notez qu'il est aussi possible de voir des overlays en <code>.dtsi</code>. Ne vous fiez donc pas uniquement au format de fichier. La principale mani\u00e8re de les diff\u00e9rencier se trouve dans leur syntaxe et la mention de <code>/plugin/</code> au d\u00e9but du fichier.</p> <p>Deux syntaxes existent : une ancienne et une nouvelle.</p> <p>Exemple de Device Tree Overlay</p> AncienneNouvelle <pre><code>/dts-v1/;\n/plugin/;\n\n/ {\n\n    fragment@0 {\n        target = &lt;&amp;fpga_full&gt;;\n        __overlay__ {\n            firmware-name = \"enc_wrapper.bit.bin\";\n        };\n    };\n\n    fragment@1 {\n        target = &lt;&amp;amba&gt;;\n        __overlay__ {\n            PetaENC_0: PetaENC@40000000 {\n                clock-names = \"s_axi_aclk\";\n                clocks = &lt;&amp;clkc 15&gt;;\n                compatible = \"generic-uio\";\n                reg = &lt;0x40000000 0x1000&gt;;\n            };\n        };\n    };\n\n};\n</code></pre> <pre><code>/dts-v1/;\n/plugin/;\n\n&amp;fpga_full {\n    firmware-name = \"enc_wrapper.bit.bin\";\n};\n\n&amp;amba {\n    PetaENC_0: PetaENC@40000000 {\n        clock-names = \"s_axi_aclk\";\n        clocks = &lt;&amp;clkc 15&gt;;\n        compatible = \"generic-uio\";\n        reg = &lt;0x40000000 0x1000&gt;;\n    };\n};\n</code></pre> <p>Ces deux exemples sont fonctionnellement \u00e9quivalents. La nouvelle syntaxe est souvent pr\u00e9f\u00e9r\u00e9e pour sa simplicit\u00e9 et sa lisibilit\u00e9.</p>"},{"location":"docs/device_tree/#exemple-dto-pour-un-encodeur","title":"Exemple DTO pour un encodeur","text":"<p>Le Device Tree est g\u00e9n\u00e9r\u00e9 automatiquement par PetaLinux \u00e0 partir d'un fichier XSA. Notre travail s'est principalement concentr\u00e9 sur la cr\u00e9ation de l'overlay. </p> <p>L'overlay que nous avons utilis\u00e9 est \u00e9crit avec l'ancienne syntaxe et permet de r\u00e9aliser plusieurs actions importantes :</p> <p>Overlay utilis\u00e9 pour la reprogrammation de l'encodeur</p> <pre><code>/dts-v1/;\n/plugin/;\n\n/ {\n\n    fragment@0 {\n        target = &lt;&amp;fpga_full&gt;;\n        __overlay__ {\n            firmware-name = \"enc_wrapper.bit.bin\";\n        };\n    };\n\n    fragment@1 {\n        target = &lt;&amp;amba&gt;;\n        __overlay__ {\n            PetaENC_0: PetaENC@40000000 {\n                clock-names = \"s_axi_aclk\";\n                clocks = &lt;&amp;clkc 15&gt;;\n                compatible = \"generic-uio\";\n                reg = &lt;0x40000000 0x1000&gt;;\n            };\n        };\n    };\n\n};\n</code></pre> <p>Dans le cas des FPGA Zynq, le <code>fragment@0</code> de l'overlay modifie la propri\u00e9t\u00e9 <code>firmware-name</code> de la r\u00e9gion FPGA/PL, sp\u00e9cifiant ainsi le bitstream \u00e0 utiliser pour la reprogrammation. </p> <p>Le <code>fragment@1</code> ajoute un nouveau composant au bus AMBA/AXI \u00e0 l'adresse m\u00e9moire <code>0x40000000</code>. Il sp\u00e9cifie \u00e9galement la clock utilis\u00e9e par le composant et son nom via <code>clock-names</code> et <code>clocks</code>, le driver \u00e0 utiliser pour communiquer avec l'appareil via la propri\u00e9t\u00e9 <code>compatible</code>, et enfin l'adresse m\u00e9moire attribu\u00e9e au composant ainsi que la taille de cette zone via <code>reg</code>.</p> <p>Ces ajouts permettent au kernel d'acc\u00e9der aux registres de notre bloc IP avec le driver UIO, facilitant ainsi l'interaction avec notre block IP.</p> Explication d\u00e9taill\u00e9e <ul> <li> <p>fragment@0 :</p> <ul> <li>target : Pointe vers la r\u00e9gion FPGA/PL.</li> <li>overlay : <ul> <li>firmware-name : Sp\u00e9cifie le nom du bitstream (<code>enc_wrapper.bit.bin</code>) \u00e0 charger pour la reprogrammation du FPGA.</li> </ul> </li> </ul> </li> <li> <p>fragment@1 :</p> <ul> <li>target : Pointe vers le bus AMBA/AXI.</li> <li>overlay :<ul> <li>PetaENC_0 : Nom du composant ajout\u00e9.</li> <li>clock-names : Nom de la clock utilis\u00e9e (<code>s_axi_aclk</code>).</li> <li>clocks : R\u00e9f\u00e9rence \u00e0 la clock configur\u00e9e (15<sup>\u00e8me</sup> entr\u00e9e dans <code>clkc</code>).</li> <li>compatible : Sp\u00e9cifie le driver (<code>generic-uio</code>) \u00e0 utiliser pour communiquer avec le composant.</li> <li>reg : Sp\u00e9cifie l'adresse m\u00e9moire (<code>0x40000000</code>) et la taille de la zone m\u00e9moire allou\u00e9e (<code>0x1000</code>).</li> </ul> </li> </ul> </li> </ul> <p>En suivant cette structure, le kernel peut acc\u00e9der aux registres de l'IP personnalis\u00e9 en utilisant le driver UIO.</p>"},{"location":"docs/device_tree/#generation-de-device-tree","title":"G\u00e9n\u00e9ration de Device Tree","text":""},{"location":"docs/device_tree/#contexte","title":"Contexte","text":"<p>La g\u00e9n\u00e9ration du Device Tree est g\u00e9n\u00e9ralement prises en charge de mani\u00e8re automatique par des outils tels que PetaLinux, qui s'appuient sur les fichiers XSA pour produire ces \u00e9l\u00e9ments. Toutefois, dans certaines situations, il peut \u00eatre int\u00e9ressant de g\u00e9n\u00e9rer soi-m\u00eame le Device Tree.</p>"},{"location":"docs/device_tree/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Vivado et Vitis install\u00e9s</li> <li>Fichier XSA g\u00e9n\u00e9r\u00e9</li> </ul>"},{"location":"docs/device_tree/#procedure","title":"Proc\u00e9dure","text":"<ol> <li> <p>Lancer XSCT</p> <p>Ouvrez un terminal et lancez XSCT :</p> <pre><code>xsct\n</code></pre> <p>Note</p> <p>Si vous avez des probl\u00e8mes pour lancer XSCT, lancer un terminal depuis vitis et ex\u00e9cuter la commande <code>xsct</code>.</p> </li> <li> <p>Charger le fichier XSA</p> <p>Utilisez la commande suivante pour charger votre fichier XSA :</p> <pre><code>hsi open_hw_design &lt;path_to_your_xsa_file&gt;\n</code></pre> </li> <li> <p>Specifier le DTG repository</p> <pre><code>git clone https://github.com/Xilinx/device-tree-xlnx\ncd device-tree-xlnx\ngit checkout &lt;xilinx_rel_v20XX.X&gt;\n</code></pre> <p>Sp\u00e9cifiez le r\u00e9pertoire DTG (Device Tree Generator) : <pre><code>hsi set_repo_path &lt;path to device-tree-xlnx repository&gt;\n</code></pre></p> </li> <li> <p>SW design</p> <p>Utilisez la commande suivante pour obtenir la liste des processeurs disponibles :</p> <pre><code>set procs [hsi get_cells -hier -filter {IP_TYPE==PROCESSOR}]\n</code></pre> <p>Choisissez le processeur que vous souhaitez utiliser pour g\u00e9n\u00e9rer le Device Tree : <pre><code>hsi create_sw_design device-tree -os device_tree -proc &lt;proc_name&gt;\n</code></pre></p> </li> <li> <p>G\u00e9n\u00e9rer le Device Tree</p> <pre><code>hsi generate_target -dir &lt;path to output file&gt;\n</code></pre> </li> <li> <p>Fermer XSCT</p> <pre><code>hsi close_hw_design [hsi current_hw_design]\nexit\n</code></pre> </li> </ol> <p>En suivant cette proc\u00e9dure, vous serez en mesure de g\u00e9n\u00e9rer . Pour compiler le Device Tree g\u00e9n\u00e9r\u00e9, r\u00e9f\u00e9rez-vous \u00e0 la documentation Xilinx officielle.</p>"},{"location":"docs/device_tree/#compilation-dun-device-tree-overlay","title":"Compilation d'un Device Tree Overlay","text":""},{"location":"docs/device_tree/#contexte_1","title":"Contexte","text":"<p>Le Device Tree Overlay (DTO) pour le Zynq ne se g\u00e9n\u00e8re pas automatiquement; il faut donc l'\u00e9crire soi-m\u00eame. Toutefois, la compilation du DTO est relativement simple gr\u00e2ce aux outils appropri\u00e9s. Voici les \u00e9tapes d\u00e9taill\u00e9es pour compiler un Device Tree Overlay.</p>"},{"location":"docs/device_tree/#prerequis_1","title":"Pr\u00e9requis","text":"<p>Pour compiler un Device Tree Overlay, vous aurez besoin du Device Tree Compiler (DTC). Ce dernier est fourni avec Vitis ou peut \u00eatre t\u00e9l\u00e9charg\u00e9 depuis le repository officiel ici.</p>"},{"location":"docs/device_tree/#procedure_1","title":"Proc\u00e9dure","text":"<pre><code>dtc -O dtb -o FICHIER.dtbo -b 0 -@ FICHIER.dtso\n</code></pre>"},{"location":"docs/fpga_manager/","title":"Programmation FPGA depuis Linux avec FPGA Manager","text":""},{"location":"docs/fpga_manager/#introduction","title":"Introduction","text":"<p>Les FPGA (Field-Programmable Gate Arrays) sont des circuits int\u00e9gr\u00e9s reprogrammables offrant une grande flexibilit\u00e9 pour diverses applications. Pour programmer ces dispositifs, des fichiers sp\u00e9cifiques sont utilis\u00e9s : les fichiers BIT et BIN. Ce guide vous explique comment g\u00e9n\u00e9rer un fichier BIN \u00e0 partir d'un fichier BIT et l'utiliser pour programmer votre FPGA en utilisant l'outil FPGA Manager sous Linux.</p>"},{"location":"docs/fpga_manager/#les-fichiers-necessaires-pour-la-programmation-fpga","title":"Les fichiers n\u00e9c\u00e9ssaires pour la programmation FPGA","text":""},{"location":"docs/fpga_manager/#quest-ce-quun-bitstream","title":"Qu'est-ce qu'un Bitstream ?","text":"<p>Un bitstream est un fichier qui contient les informations n\u00e9cessaires pour configurer un FPGA. Il d\u00e9termine comment les ressources logiques et les interconnexions du FPGA doivent \u00eatre programm\u00e9es pour effectuer des t\u00e2ches sp\u00e9cifiques. Les bitstreams peuvent \u00eatre g\u00e9n\u00e9r\u00e9s \u00e0 l'aide d'outils de conception FPGA comme Vivado.</p>"},{"location":"docs/fpga_manager/#differences-entre-fichiers-bit-et-bin","title":"Diff\u00e9rences entre Fichiers BIT et BIN","text":"Caract\u00e9ristique Fichiers BIT (Bitstream) Fichiers BIN Contenu Inclut les informations n\u00e9cessaires pour programmer les ressources logiques et les interconnexions du FPGA. Versions binaires du bitstream de configuration. Compatibles avec les outils de gestion FPGA sous Linux. G\u00e9n\u00e9ration G\u00e9n\u00e9r\u00e9s par des outils de synth\u00e8se et de placement/routage comme <code>Vivado</code>. G\u00e9n\u00e9r\u00e9s \u00e0 partir des fichiers BIT en utilisant l'outil <code>bootgen</code>. <p>Pourquoi utiliser un fichier BIN ?</p> <p>Les fichiers BIN sont utilis\u00e9s pour charger les bitstreams dans les FPGA depuis un environnement Linux. Ils sont compatibles avec les outils de gestion FPGA comme FPGA Manager. Il n'est pas possible de charger directement un fichier BIT dans un FPGA depuis Linux.</p>"},{"location":"docs/fpga_manager/#generation-dun-fichier-bin-a-partir-dun-fichier-bit","title":"G\u00e9n\u00e9ration d'un Fichier BIN \u00e0 partir d'un Fichier BIT","text":"<p>bootgen est un outil fourni par Xilinx qui permet de g\u00e9n\u00e9rer des fichiers BIN \u00e0 partir de fichiers BIF (Boot Image Format). L'outil est fourni avec Vitis de base et n'est pas disponible directement en open-source. Il se situe g\u00e9n\u00e9ralement dans le dossier d'installation de Vitis, par exemple avec la version 2023.1 <code>Vitis/2023.1/bin/</code>.</p> <p>Pour g\u00e9n\u00e9rer un fichier BIN \u00e0 partir d'un fichier BIT, nomm\u00e9 ici <code>project.bit</code>, suivez ces \u00e9tapes :</p> <ol> <li> <p>Cr\u00e9ez un fichier de configuration BIF nomm\u00e9 <code>project.bif</code> dans le m\u00eame r\u00e9pertoire que votre fichier <code>project.bit</code> avec le contenu suivant :</p> project.bif<pre><code>all:\n{\n    project.bit /* Nom du fichier Bitstream */\n}\n</code></pre> <p>Plus d'informations sur le format BIF sont disponibles dans la documentation Xilinx.</p> </li> <li> <p>Utilisez la commande <code>bootgen</code>, situ\u00e9 par exemple avec la version 2023.1 dans <code>Vitis/2023.1/bin/</code>, pour g\u00e9n\u00e9rer le fichier BIN dans le m\u00eame r\u00e9pertoire que le BIF :</p> <pre><code>bootgen -image project.bif -arch zynq -process_bitstream bin\n</code></pre> </li> </ol> <p>NE PAS UTILISER VIVADO !</p> <p>Vivado g\u00e9n\u00e8re des fichiers BIN qui ne sont pas compatibles avec le chargement du FPGA depuis Linux. Pour g\u00e9n\u00e9rer un fichier BIN compatible, utilisez <code>bootgen</code>.</p> <pre><code>Param\u00e8tres -&gt; Bitstream -&gt; -bin_file : activer\n</code></pre> <p>Le fichier sera g\u00e9n\u00e9r\u00e9 dans <code>proj_name/proj_name.runs/impl_1</code> ne sera pas compatible avec le chargement du FPGA depuis Linux.</p> <p>l'utilisation de <code>bootgen</code> est n\u00e9cessaire pour g\u00e9n\u00e9rer un fichier BIN compatible.</p>"},{"location":"docs/fpga_manager/#fpga-manager","title":"FPGA Manager","text":""},{"location":"docs/fpga_manager/#introduction-a-fpga-manager","title":"Introduction \u00e0 FPGA Manager","text":"<p>FPGA Manager est une interface du noyau Linux qui permet de charger et de g\u00e9rer les bitstreams des FPGA. Il simplifie l'interaction avec le FPGA en exposant des fichiers virtuels \u00e0 travers le syst\u00e8me de fichiers Linux, ce qui facilite la reconfiguration et la mise \u00e0 jour des FPGA.</p> <p>Composants Principaux du FPGA Manager</p> <ul> <li> <p>flags : Ce fichier permet de d\u00e9finir des options pour le chargement du bitstream. Par exemple, d\u00e9finir la valeur \u00e0 <code>0</code> pour indiquer un bitstream complet.</p> <p>Plus d'informations sur les types de bitstreams fournies par le support xilinx</p> </li> <li> <p>firmware : Ce fichier est utilis\u00e9 pour sp\u00e9cifier le nom du bitstream \u00e0 charger. Le bitstream doit \u00eatre plac\u00e9 dans le r\u00e9pertoire <code>/lib/firmware</code>.</p> </li> </ul> <p>Activation du FPGA Manager</p> <p>Avant de pouvoir utiliser FPGA Manager, vous devez vous assurer qu'il est activ\u00e9 dans votre configuration PetaLinux. Suivez les \u00e9tapes d\u00e9taill\u00e9es dans le guide PetaLinux Tools Documentation: Reference Guide (UG1144) pour activer FPGA Manager pour les dispositifs Zynq-7000 et Zynq UltraScale MPSoC.</p>"},{"location":"docs/fpga_manager/#mise-a-jour-du-fpga-depuis-linux","title":"Mise \u00e0 Jour du FPGA depuis Linux","text":"<p>Suivez les \u00e9tapes ci-dessous pour mettre \u00e0 jour le FPGA en utilisant FPGA Manager. (source)</p> Sans DTOAvec DTO <ol> <li> <p>Connectez-vous en tant qu'utilisateur root :</p> <pre><code>sudo -i\n</code></pre> </li> <li> <p>D\u00e9finissez les flags pour le Bitstream complet :</p> <pre><code>echo 0 &gt; /sys/class/fpga_manager/fpga0/flags\n</code></pre> </li> <li> <p>Chargez le Bitstream dans le PL :</p> <pre><code>mkdir -p /lib/firmware\ncp project.bit.bin /lib/firmware/\necho project.bit.bin &gt; /sys/class/fpga_manager/fpga0/firmware\n</code></pre> </li> <li> <p>F\u00e9licitations, le FPGA a \u00e9t\u00e9 mis \u00e0 jour avec succ\u00e8s !</p> </li> </ol> <ol> <li> <p>Pr\u00e9paration du Device Tree Overlay (DTO)</p> <p>Assurez-vous que votre DTO est correctement configur\u00e9 pour votre projet. La configuration et compilation d'un DTO est d\u00e9taill\u00e9e dans la section Les Devices Tree.</p> <p>Vous devez avoir un fichier <code>.dtbo</code> pr\u00eat \u00e0 \u00eatre utilis\u00e9 pour configurer le FPGA.</p> </li> <li> <p>Chargement du DTO et Programmation du FPGA</p> <ol> <li> <p>Connectez-vous en tant qu'utilisateur root :</p> <pre><code>sudo -i\n</code></pre> </li> <li> <p>D\u00e9finissez les flags pour le Bitstream complet :</p> <pre><code>echo 0 &gt; /sys/class/fpga_manager/fpga0/flags\n</code></pre> </li> <li> <p>Copiez le Bitstream et le DTBO dans le r\u00e9pertoire <code>/lib/firmware</code> :</p> <pre><code>mkdir -p /lib/firmware\ncp project.bit.bin /lib/firmware/project.bit.bin\ncp pl.dtbo /lib/firmware/\n</code></pre> </li> <li> <p>Appliquez le DTBO :</p> <pre><code>mkdir /configfs\nmount -t configfs configfs /configfs\ncd /configfs/device-tree/overlays/\nmkdir full\necho -n \"pl.dtbo\" &gt; full/path\n</code></pre> <p>Remarque</p> <p>Lorsque vous appliquez un DTBO, le FPGA est automatiquement programm\u00e9 avec le bitstream sp\u00e9cifi\u00e9 dans le DTO.</p> </li> <li> <p>F\u00e9licitations, votre FPGA a \u00e9t\u00e9 mis \u00e0 jour avec succ\u00e8s en utilisant un DTO !</p> </li> </ol> <p>Suppression du DTBO</p> <p>Pour supprimer le DTBO :</p> <pre><code>cd /configfs/device-tree/overlays/\nrmdir full\n</code></pre> </li> </ol>"},{"location":"docs/linux_zybo/","title":"Installation de Linux sur la Zybo Z7-20 avec PetaLinux","text":""},{"location":"docs/linux_zybo/#introduction","title":"Introduction","text":"<p>La Zybo Z7-20 est une carte de d\u00e9veloppement bas\u00e9e sur un FPGA Zynq-7000 de Xilinx, qui combine un processeur ARM Cortex-A9 bic\u0153ur et des ressources logiques programmables.</p> <p>Ce guide a pour objectif de d\u00e9crire l'installation et la configuration de Linux sur la Zybo Z7-20 en utilisant Vivado pour la g\u00e9n\u00e9ration du mat\u00e9riel et PetaLinux pour la cr\u00e9ation du syst\u00e8me d'exploitation embarqu\u00e9.</p>"},{"location":"docs/linux_zybo/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Vivado : Pour g\u00e9n\u00e9rer le bitstream et le XSA. T\u00e9l\u00e9charger Vivado.</li> <li>PetaLinux : Pour g\u00e9n\u00e9rer le syst\u00e8me de fichiers, le FSBL (First Stage Bootloader), U-Boot et le noyau Linux. Guide d'installation PetaLinux.</li> </ul>"},{"location":"docs/linux_zybo/#generation-du-materiel","title":"G\u00e9n\u00e9ration du Mat\u00e9riel","text":"<p>L'objectif est de g\u00e9n\u00e9rer un fichier XSA \u00e0 partir du projet Vivado pour l'utiliser dans PetaLinux.</p> <p>Qu'est-ce qu'un fichier XSA ?</p> <p>Le fichier XSA contient toutes les informations n\u00e9cessaires sur le design mat\u00e9riel, y compris les configurations des blocs IP, les contraintes de timing, les p\u00e9riph\u00e9riques et les connexions internes. Il inclut \u00e9galement le bitstream g\u00e9n\u00e9r\u00e9.</p> <p>Nous utilisons le d\u00e9p\u00f4t officiel de la Zybo Z7-20 disponible sur GitHub en suivant le guide Digilent FPGA Demo Git Repositories. Ce d\u00e9p\u00f4t contient une d\u00e9monstration de la Zybo Z7-20 avec un design mat\u00e9riel complet et pr\u00eat \u00e0 \u00eatre utilis\u00e9.</p> <p>Attention</p> <p>Le d\u00e9pot n'est pas mis \u00e0 jour pour la version 2023.2 de Vivado, mais Vivado est capable de mettre \u00e0 jour les IPs automatiquement.</p> <ol> <li> <p>Cloner le d\u00e9p\u00f4t :</p> <pre><code>git clone --recursive https://github.com/Digilent/Zybo-Z7\ncd Zybo-Z7\ngit checkout remotes/origin/20/Petalinux/master\ngit submodule update --init --recursive\n</code></pre> </li> <li> <p>Cr\u00e9er le projet Vivado en utilisant la commande suivante dans la console Tcl pour importer le projet :</p> <p><pre><code>set argv \"\"; source {local root repo}/hw/scripts/checkout.tcl\n</code></pre> Veiullez remplacer <code>{local root repo}</code> par le chemin absolu du d\u00e9p\u00f4t clon\u00e9.</p> </li> <li> <p>G\u00e9n\u00e9rer le bitstream. Un bitstream est un fichier binaire contenant la configuration compl\u00e8te pour programmer un FPGA. Il d\u00e9crit les connexions et les configurations des \u00e9l\u00e9ments logiques programmables en fonction de votre design mat\u00e9riel dans Vivado.</p> <p>Erreur</p> <pre><code>[IP_Flow 19-4965] IP ila_pixclk was packaged with board value 'digilentinc.com:zybo-z7-10:part0:1.0'. Current project's board value is 'digilentinc.com:zybo-z7-20:part0:1.1'. Please update the project settings to match the packaged IP.\n</code></pre> <ul> <li>Solution Optionelle : Mettre \u00e0 jour l'IP <code>ila_pixclk</code> pour correspondre \u00e0 la valeur de la carte Zybo-Z7-20. Cette erreur n'affecte pas la g\u00e9n\u00e9ration du bitstream ou le fonctionnement ult\u00e9rieur.</li> </ul> </li> <li> <p>Exporter le mat\u00e9riel en g\u00e9n\u00e9rant le fichier XSA (Hardware Specification Archive). </p> </li> </ol> <p>Nous avons maintenant un fichier XSA que nous pouvons utiliser pour g\u00e9n\u00e9rer le syst\u00e8me d'exploitation avec PetaLinux.</p>"},{"location":"docs/linux_zybo/#generation-du-systeme-dexploitation","title":"G\u00e9n\u00e9ration du Syst\u00e8me d'Exploitation","text":""},{"location":"docs/linux_zybo/#petalinux","title":"Petalinux","text":"<p>PetaLinux est un outil de d\u00e9veloppement d'OS embarqu\u00e9 qui simplifie le processus de cr\u00e9ation d'un syst\u00e8me d'exploitation Linux embarqu\u00e9 pour les syst\u00e8mes Zynq-7000, Zynq UltraScale+ MPSoC et MicroBlaze. L'objectif est d'utiliser le fichier XSA g\u00e9n\u00e9r\u00e9 pr\u00e9c\u00e9demment pour cr\u00e9er un syst\u00e8me d'exploitation Linux embarqu\u00e9 pour la Zybo Z7-20.</p> <ol> <li> <p>Cr\u00e9er un nouveau projet</p> <p>G\u00e9n\u00e9rer un projet \u00e0 partir du template Zynq :</p> <pre><code>petalinux-create --type project --template zynq --name petalinux_zybo\n</code></pre> </li> <li> <p>Configurer le projet</p> <p>Configurer le projet avec le fichier XSA pr\u00e9c\u00e9demment g\u00e9n\u00e9r\u00e9 :</p> <pre><code>cd petalinux_zybo\npetalinux-config --get-hw-description=&lt;chemin_du_fichier_xsa&gt;\n</code></pre> <p>Veillez \u00e0 activer les options suivantes :</p> <ul> <li>Image Packaging Configuration -&gt; Root filesystem type : Changer en <code>EXT4</code>.</li> <li>FPGA Manager -&gt; FPGA Manager : Activer le FPGA Manager.</li> </ul> <p>Petalinux 2023.2</p> <p>Une erreur est pr\u00e9sente dans la version 2023.2 de PetaLinux au niveau des bootargs, <code>ro</code> est pr\u00e9sent \u00e0 la place de <code>rw</code>. </p> <p>Une solution possible est de rajouter <code>rw</code> aux bootargs dans DTG Settings -&gt; Kernel bootargs -&gt; Add extra boot args.</p> D\u00e9finir l'adresse MAC dans Petalinux <p>Dans le menu de configuration Petalinux (<code>petalinux-config</code>), naviguez vers <code>Subsystem AUTO Hardware Settings &gt; Ethernet Settings</code> pour d\u00e9finir l'adresse MAC de l'interface Ethernet. Vous avez deux principales options pour d\u00e9finir l'adresse MAC :</p> <ol> <li> <p>Sp\u00e9cifier une adresse MAC statique :</p> <ul> <li>Entrez directement l'adresse MAC souhait\u00e9e dans le champ <code>Ethernet MAC address</code>.</li> </ul> </li> <li> <p>Activer la g\u00e9n\u00e9ration d'une adresse MAC al\u00e9atoire :</p> <ul> <li>Activez l'option <code>Randomise MAC address</code>. Cela vous permet de d\u00e9finir un mod\u00e8le pour l'adresse MAC en utilisant le caract\u00e8re <code>?</code> pour sp\u00e9cifier des valeurs al\u00e9atoires.</li> <li>Exemple : <code>00:0a:35:00:??:??</code> \u2013 Ce mod\u00e8le fixe les quatre premiers octets et rend les deux derniers octets al\u00e9atoires.</li> </ul> </li> </ol> <p>Remarque : Si vous avez configur\u00e9 une adresse MAC dans U-Boot, l'adresse MAC de l'environnement U-Boot aura la priorit\u00e9 sur la configuration Petalinux.</p> <p>Remarque : Lors de l'utilisation de l'option <code>Randomise MAC address</code>, l'interface se verra attribuer une adresse MAC lors du premier d\u00e9marrage et conservera cette adresse pour les d\u00e9marrages suivants.</p> <p>Pour plus d'informations d\u00e9taill\u00e9es, consultez le Guide de R\u00e9f\u00e9rence des Outils Petalinux de AMD (UG1144).</p> </li> <li> <p>Configurer le noyau</p> <pre><code>petalinux-config -c kernel\n</code></pre> <p>Veillez \u00e0 activer les options suivantes du noyau :</p> <ul> <li> <p>File systems -&gt; Ext4 POSIX Access Control Lists : Activer.</p> </li> <li> <p>File systems -&gt; Kernel automounter support (supports v3, v4 and v5) : Activer.</p> </li> <li> <p>Executable file formats -&gt; Kernel support for MISC binaries : Activer.</p> </li> </ul> </li> <li> <p>Compiler &amp; G\u00e9n\u00e9rer les Fichiers N\u00e9cessaires</p> <ol> <li> <p>compiler le projet :</p> <pre><code>petalinux-build\n</code></pre> <p>Erreur</p> <pre><code>[libtinfo.so.5: cannot open shared object file: No such file or directory]\n</code></pre> <ul> <li>Solution : Sur Ubuntu, installer la biblioth\u00e8que requise :</li> </ul> <pre><code>sudo apt-get install libtinfo5\n</code></pre> <p>Avertissement</p> <pre><code>The busybox:do_fetch sig is computed to be e69f899fec71b53e8a81fc4af8d446ffaed28c1f02b202fa8cb783dce7c0d2e4, but the sig is locked to 4dcaff8c51438430803be8fa00f31476d3041a4c2d22474848e638e2fe9ebaba in SIGGEN_LOCKEDSIGS_t-cortexa9t2hf-neon\n</code></pre> <ul> <li>Note : Cet avertissement dans la version 2023.2 (et non 2023.1) concernant <code>busybox:do_fetch sig</code> est normal et n'affecte pas le processus. Support Xilinx.</li> </ul> </li> <li> <p>G\u00e9n\u00e9rer l'image de d\u00e9marrage :</p> <pre><code>petalinux-package --boot --u-boot\n</code></pre> </li> <li> <p>Vous devriez avoir les fichiers suivants dans le r\u00e9pertoire <code>./images/linux</code> :</p> <pre><code>BOOT.BIN\nboot.scr\nimage.ub\n</code></pre> </li> </ol> </li> </ol>"},{"location":"docs/linux_zybo/#root-file-system","title":"Root File System","text":"<p>Des distributions minimales Debian/Ubuntu sont disponibles sur eewiki minfs.  T\u00e9l\u00e9chargez, par exemple, <code>debian-12.1-minimal-armhf-2023-08-22.tar.xz</code>. Veillez utiliser la version <code>armhf</code>.</p> <p>Note</p> <p>Il est possible de g\u00e9n\u00e9rer un RFS personnalis\u00e9 nottament avec <code>debootstrap</code> ou <code>buildroot</code>.</p>"},{"location":"docs/linux_zybo/#preparation-de-la-carte-sd","title":"Pr\u00e9paration de la Carte SD","text":"<ol> <li> <p>Formater la Carte SD avec les partitions n\u00e9cessaires. (Source)</p> <ul> <li>Aligner \u00e0 4MiB.</li> <li>Premi\u00e8re partition : \"BOOT\", Au moins 500 MB. Formater en FAT32. 4MiB libres avant la premi\u00e8re partition.</li> <li>Deuxi\u00e8me partition : \"RootFS\", Utiliser l'espace restant. Formater en EXT4.</li> </ul> Proc\u00e9dure pour formater une carte SD avec <code>fdisk</code> <p>\u00c9tape 1: Lister les devices disponibles</p> <p>D'abord, lister tous les devices de stockage disponibles pour identifier le device correspondant \u00e0 la carte SD.</p> <pre><code>sudo fdisk -l\n</code></pre> <p>Cherchez votre carte SD dans la liste des devices. Supposons qu'il s'agit de <code>/dev/mmcblk0</code> dans cet exemple.</p> <p>\u00c9tape 2: D\u00e9marrer <code>fdisk</code> pour partitionner la carte SD</p> <p>D\u00e9marrez <code>fdisk</code> sur le device de la carte SD.</p> <pre><code>sudo fdisk /dev/mmcblk0\n</code></pre> <p>\u00c9tape 3: Ajouter une nouvelle partition</p> <ol> <li> <p>Ajouter une nouvelle partition:</p> <pre><code>Command (m for help): n\n</code></pre> <ul> <li>Choisir le type de partition : primaire (<code>p</code>).</li> <li>Num\u00e9ro de partition : 1.</li> <li>Premier secteur : 8192.</li> <li>Dernier secteur : +500M (pour cr\u00e9er une partition de 500 MiB).</li> </ul> <pre><code>Partition type\n   p   primary (0 primary, 0 extended, 4 free)\nSelect (default p): p\nPartition number (1-4, default 1): 1\nFirst sector (2048-15523839, default 2048): 8192\nLast sector, +/-sectors or +/-size{K,M,G,T,P} (8192-15523839, default 15523839): +500M\n</code></pre> </li> <li> <p>Ajouter une seconde partition:</p> <pre><code>Command (m for help): n\n</code></pre> <ul> <li>Choisir le type de partition : primaire (<code>p</code>).</li> <li>Num\u00e9ro de partition : 2.</li> <li>Premier secteur : utiliser le meme secteur que la fin de la premi\u00e8re partition afin de laisser fdisck calculer l'espace restant.</li> <li>Dernier secteur : laisser par d\u00e9faut pour utiliser l'espace restant.</li> </ul> <pre><code>Command (m for help): n\n Partition type\n    p   primary (1 primary, 0 extended, 3 free)\n    e   extended (container for logical partitions)\n Select (default p): p\n Partition number (2-4, default 2): 2\n First sector (2048-15523839, default 2048): 8192\n\n Sector 8192 is already allocated.\n First sector (1032192-15523839, default 1032192): [Appuyer sur Entr\u00e9e pour prendre par d\u00e9faut]\n Last sector, +/-sectors or +/-size{K,M,G,T,P} (1032192-15523839, default 15523839): : [Appuyer sur Entr\u00e9e pour prendre par d\u00e9faut]\n</code></pre> </li> </ol> <p>\u00c9tape 4: \u00c9crire les changements</p> <p>\u00c9crire les modifications sur le disque et quitter <code>fdisk</code>:</p> <pre><code>Command (m for help): w\n</code></pre> <p>\u00c9tape 5: Formater les partitions</p> <ol> <li> <p>Lister les partitions pour confirmer les nouvelles partitions:</p> <pre><code>sudo fdisk -l\n</code></pre> </li> <li> <p>Formater la premi\u00e8re partition en FAT32:</p> <pre><code>sudo mkfs.fat -F 32 /dev/mmcblk0p1\n</code></pre> </li> <li> <p>Formater la seconde partition en ext4:</p> <pre><code>sudo mkfs.ext4 /dev/mmcblk0p2\n</code></pre> </li> </ol> Exemple carte SD pr\u00e9par\u00e9e <pre><code>Num\u00e9ro de partition (1,2, 2 par d\u00e9faut) : 1\n\n     Device: /dev/mmcblk0p1\n      Start: 8192\n        End: 1032191\n    Sectors: 1024000\n  Cylinders: 16001\n       Size: 500M\n         Id: 83\n       Type: Linux\nStart-C/H/S: 128/0/1\n  End-C/H/S: 1023/3/16\n\nCommande (m pour l'aide) : i\nNum\u00e9ro de partition (1,2, 2 par d\u00e9faut) : 2\n\n     Device: /dev/mmcblk0p2\n      Start: 1032192\n        End: 60751871\n    Sectors: 59719680\n  Cylinders: 933121\n       Size: 28,5G\n         Id: 83\n       Type: Linux\nStart-C/H/S: 1023/3/16\n  End-C/H/S: 1023/3/16\n</code></pre> <pre><code>lsblk -fs\nNAME      FSTYPE FSVER LABEL                 UUID                                 FSAVAIL FSUSE% MOUNTPOINTS\nsda1      vfat   FAT32                       84C0-4ABA                             579,8M     3% /boot/efi\n\u2514\u2500sda\nsda2      ext4   1.0                         4187e4a5-99f2-481b-b7fd-a80cf2a1d054    601M    31% /boot\n\u2514\u2500sda\nsda3      btrfs        fedora_localhost-live b630913f-76fe-45d9-bb4f-62c1e6005aeb  172,4G    22% /home\n\u2502                                                                                                /\n\u2514\u2500sda\nsr0\nmmcblk0p1 vfat   FAT32                       EC04-463A\n\u2514\u2500mmcblk0\nmmcblk0p2 ext4   1.0                         29000ca8-9682-4bc6-ab5a-9963948fa3a5\n\u2514\u2500mmcblk0\n</code></pre> <pre><code>lsblk -a\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsda           8:0    0 223,6G  0 disk \n\u251c\u2500sda1        8:1    0   600M  0 part /boot/efi\n\u251c\u2500sda2        8:2    0     1G  0 part /boot\n\u2514\u2500sda3        8:3    0   222G  0 part /home\n                                      /\nsr0          11:0    1  1024M  0 rom\nmmcblk0     179:0    0    29G  0 disk \n\u251c\u2500mmcblk0p1 179:1    0   500M  0 part \n\u2514\u2500mmcblk0p2 179:2    0  28,5G  0 part \nzram0       252:0    0   7,6G  0 disk [SWAP]\n</code></pre> </li> <li> <p>Copier les Images. (Source)</p> <ul> <li>Copier <code>BOOT.BIN</code>, <code>boot.scr</code>, <code>image.ub</code> dans la partition boot.</li> <li>Copier le <code>rootfs</code> dans la partition rootfs puis d\u00e9compresser.</li> </ul> </li> </ol>"},{"location":"docs/linux_zybo/#demarrage-de-la-zybo-z7-20","title":"D\u00e9marrage de la Zybo Z7-20","text":"<ol> <li> <p>Ins\u00e9rez la carte SD dans votre Zybo Z7-20 et configurez la carte pour d\u00e9marrer depuis la carte SD. (Digilent Zybo Z7-20 Reference Manual section 2.1)</p> <ul> <li>Ins\u00e9rez la carte microSD dans le connecteur J4.</li> <li>Attachez une source d'alimentation \u00e0 la Zybo Z7 et s\u00e9lectionnez-la en utilisant JP6.</li> <li>Placez un seul cavalier sur JP5, reliant les deux broches les plus \u00e0 gauche (\u00e9tiquet\u00e9es \"SD\").</li> <li>Allumez la carte. La carte d\u00e9marrera maintenant l'image sur la carte microSD.</li> </ul> </li> <li> <p>Allumez la carte et surveillez le processus de d\u00e9marrage via une connexion s\u00e9rie.</p> <p>Lancer un terminal s\u00e9rie type gtkterm ou autre sur le bon port avec un baud rate de 115200, 8 bits et 1 bit de stop et aucun bit de parit\u00e9</p> </li> <li> <p>Vous devriez voir le d\u00e9marrage de Linux sur votre Zybo Z7-20. Have fun !</p> </li> </ol> <p>Probl\u00e8mes Connus lors du D\u00e9marrage</p> <p><pre><code>Starting init: /bin/sh exists but couldn't execute it (error -5)\nKernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.\n</code></pre> - Solution : Le RootFS est corrompu. Refaites la copie du RootFS sur la carte SD en v\u00e9rifiant le sha256sum.</p>"},{"location":"docs/pmodenc_baremetal/","title":"Application Encoder sur baremetal Zybo","text":""},{"location":"docs/pmodenc_baremetal/#introduction","title":"Introduction","text":"<p>Ce projet a pour but de contr\u00f4ler un encodeur rotatif Digilent PmodENC sur la carte Zybo Z7-20 en utilisant un projet baremetal en C avec Vitis. L'encodeur rotatif est un composant qui permet de mesurer la rotation d'un axe. Il est compos\u00e9 de deux signaux A et B qui sont en quadrature. L'encodeur est connect\u00e9 au port JE de la carte Zybo Z7-20.</p> <p>Ce projet est disponible sur GitHub.</p>"},{"location":"docs/pmodenc_baremetal/#generation-du-materiel-avec-vivado","title":"G\u00e9n\u00e9ration du Mat\u00e9riel avec Vivado","text":"<p>L'objectif est de g\u00e9n\u00e9rer un fichier XSA. Vous pouvez vous r\u00e9f\u00e9rer au Tutoriel Pmod-IPs Digilent pour plus d'informations.</p>"},{"location":"docs/pmodenc_baremetal/#etapes","title":"\u00c9tapes","text":"<ol> <li> <p>Cr\u00e9er un projet Vivado avec la carte Zybo Z7-20.</p> </li> <li> <p>Cr\u00e9er un block design et y ajouter les \u00e9l\u00e9ments suivants :</p> <ul> <li>Zynq</li> <li>PmodENC_v1_0 connect\u00e9 au port JE</li> </ul> </li> <li> <p>Connecter automatiquement les composants puis valider le design.</p> </li> <li> <p>G\u00e9n\u00e9rer le bitstream.</p> </li> <li> <p>Exporter le mat\u00e9riel avec le bitstream inclus.</p> </li> </ol>"},{"location":"docs/pmodenc_baremetal/#application-baremetal-avec-vitis","title":"Application Baremetal avec Vitis","text":"<p>Depuis Vivado, s\u00e9lectionner <code>Tools -&gt; Launch Vitis IDE</code>.</p>"},{"location":"docs/pmodenc_baremetal/#etapes_1","title":"\u00c9tapes","text":"<ol> <li>Ouvrir un workspace.</li> <li>Cr\u00e9er un composant plateforme :<ul> <li>Nom : platform_enc</li> <li>S\u00e9lectionner le fichier XSA pr\u00e9c\u00e9demment g\u00e9n\u00e9r\u00e9</li> </ul> </li> <li>Cr\u00e9er un composant application :<ul> <li>Nom : app_enc</li> <li>Plateforme : platform_enc (cr\u00e9\u00e9 pr\u00e9c\u00e9demment)</li> </ul> </li> </ol>"},{"location":"docs/pmodenc_baremetal/#importer-les-fichiers-necessaires","title":"Importer les fichiers n\u00e9cessaires","text":"<ul> <li>Copier <code>PmodENC.c</code> et <code>PmodENC.h</code> disponibles depuis <code>platform_enc/Source/hw/sdt/drivers/PmodENC_V1_0/src</code> dans <code>app_enc/Sources/src</code>.</li> <li>Copier <code>main.c</code> disponible depuis <code>platform_enc/Source/hw/sdt/drivers/PmodENC_V1_0/examples</code> dans <code>app_enc/Sources/src</code>.</li> </ul>"},{"location":"docs/pmodenc_baremetal/#configuration-du-gpio","title":"Configuration du GPIO","text":"<p>Ajouter la ligne suivante dans le fichier <code>main.c</code> :</p> <p><pre><code>#define XPAR_PMODENC_0_AXI_LITE_GPIO_BASEADDR 0x40000000\n</code></pre> Cette definition est n\u00e9cessaire pour sp\u00e9cifier l'adresse de base du GPIO. Cette adresse est d\u00e9finie dans le device tree. Veillez \u00e0 ce que cette adresse corresponde \u00e0 celle d\u00e9finie dans le device tree.</p>"},{"location":"docs/pmodenc_baremetal/#configuration-du-projet","title":"Configuration du projet","text":"<p>Il est n\u00e9cessaire de configurer le projet pour qu'il puisse \u00eatre ex\u00e9cut\u00e9 sur la carte Zybo Z7-20. Modifier <code>Board Initialization</code> \u00e0 <code>FSBL</code> dans le fichier <code>launch.json</code>.</p>"},{"location":"docs/pmodenc_baremetal/#compilation-et-connexion","title":"Compilation et connexion","text":"<ol> <li>Compiler l'application (plateforme incluse).</li> <li>Connecter le module ENC \u00e0 la partie sup\u00e9rieure du port JE.</li> <li>Brancher le c\u00e2ble USB \u00e0 l'ordinateur.</li> <li>Connecter vous au terminal s\u00e9rie. 115200 bauds.</li> <li>Lancer l'application.</li> </ol>"},{"location":"docs/pmodenc_ip/","title":"Digilent PmodENC - Bloc IP personnalis\u00e9","text":""},{"location":"docs/pmodenc_ip/#introduction","title":"Introduction","text":"<p>Le Digilent PmodENC est un module d'entr\u00e9e rotatif qui permet aux utilisateurs d'ajouter une interface de contr\u00f4le rotative \u00e0 leurs projets FPGA. Ce module inclut un encodeur rotatif, un bouton-poussoir int\u00e9gr\u00e9 et un switch. Plus d'informations sur ce composant peuvent \u00eatre trouv\u00e9es sur la page officielle du PmodENC.</p> <p>Digilent propose un bloc IP officiel pour le PmodENC, mais il ne correspond pas \u00e0 nos besoins car son utilisation n\u00e9cessite de coder le compteur 4 bits et l'antirebond du c\u00f4t\u00e9 PS au lieu du c\u00f4t\u00e9 PL. Nous avons donc cr\u00e9\u00e9 un simple bloc IP incluant un compteur 4 bits en module RTL cod\u00e9 en VHDL.</p>"},{"location":"docs/pmodenc_ip/#conception","title":"Conception","text":"<p>Le bloc IP PetaENC est constitu\u00e9 de :</p> <ul> <li>Un bloc AXI GPIO, contenant des registres accessibles par bus AXI.</li> <li>Le module RTL du compteur, comportant \u00e9galement un antirebond, le tout en VHDL.</li> <li>Un bloc Pmod Bridge, permettant d'interfacer le Pmod avec le module.</li> </ul> <p></p>"},{"location":"docs/pmodenc_ip/#utilisation","title":"Utilisation","text":"<p>Le bloc IP PetaENC est \u00e0 relier \u00e0 un AXI Interconnect ma\u00eetre et aux broches du connecteur Pmod. Il est recommand\u00e9 de passer par un fichier de contraintes XDC pour connecter le port Pmod \u00e0 des broches externes.</p>"},{"location":"docs/pmodenc_ip/#ajout-du-bloc-ip-a-vivado","title":"Ajout du Bloc IP \u00e0 Vivado","text":"<ol> <li> <p>Cloner le R\u00e9pertoire IP :     Tout d'abord, clonez le r\u00e9pertoire sur votre machine locale :</p> <pre><code>git clone https://github.com/TER-Zybo/PetaENC_IP\n</code></pre> </li> <li> <p>Ouvrir Vivado :     Lancez Xilinx Vivado Design Suite sur votre ordinateur.</p> </li> <li> <p>Ajouter le R\u00e9pertoire IP :</p> <ul> <li>Dans Vivado, allez dans <code>Tools &gt; Project Settings</code>.</li> <li>Naviguez jusqu'\u00e0 <code>IP &gt; Repository</code>.</li> <li>Cliquez sur le bouton <code>+</code> pour ajouter un nouveau r\u00e9pertoire IP.</li> <li>Parcourez l'emplacement du r\u00e9pertoire clon\u00e9 et s\u00e9lectionnez le r\u00e9pertoire.</li> <li>Cliquez sur <code>OK</code> pour ajouter le r\u00e9pertoire.</li> </ul> </li> <li> <p>Ajouter l'IP \u00e0 Votre Projet :</p> <ul> <li>Une fois le r\u00e9pertoire ajout\u00e9, vous pouvez ajouter le bloc IP PetaENC \u00e0 votre projet depuis le catalogue IP.</li> </ul> </li> </ol>"},{"location":"docs/pmodenc_ip/#exemple-de-fichier-de-contraintes-xdc","title":"Exemple de Fichier de Contraintes (XDC)","text":"<p>Voici un exemple de la mani\u00e8re dont vous pouvez mapper le port Pmod \u00e0 des broches externes en utilisant un fichier XDC :</p> <pre><code>set_property PACKAGE_PIN &lt;num\u00e9ro_de_broche&gt; [get_ports {&lt;nom_du_port&gt;}]\nset_property IOSTANDARD LVCMOS33 [get_ports {&lt;nom_du_port&gt;}]\n</code></pre> <p>Remplacez <code>&lt;num\u00e9ro_de_broche&gt;</code> et <code>&lt;nom_du_port&gt;</code> par les valeurs appropri\u00e9es pour votre conception.</p> <p>Configuration recommand\u00e9e pour le JE</p> <p><pre><code>set_property -dict { PACKAGE_PIN V12   IOSTANDARD LVCMOS33 } [get_ports { Pmod_out_0_pin1_io }]; #IO_L4P_T0_34 Sch=je[1]                         \nset_property -dict { PACKAGE_PIN W16   IOSTANDARD LVCMOS33 } [get_ports { Pmod_out_0_pin2_io }]; #IO_L18N_T2_34 Sch=je[2]                     \nset_property -dict { PACKAGE_PIN J15   IOSTANDARD LVCMOS33 } [get_ports { Pmod_out_0_pin3_io }]; #IO_25_35 Sch=je[3]                          \nset_property -dict { PACKAGE_PIN H15   IOSTANDARD LVCMOS33 } [get_ports { Pmod_out_0_pin4_io }]; #IO_L19P_T3_35 Sch=je[4]                     \nset_property -dict { PACKAGE_PIN V13   IOSTANDARD LVCMOS33 } [get_ports { Pmod_out_0_pin7_io }]; #IO_L3N_T0_DQS_34 Sch=je[7]                  \nset_property -dict { PACKAGE_PIN U17   IOSTANDARD LVCMOS33 } [get_ports { Pmod_out_0_pin8_io }]; #IO_L9N_T1_DQS_34 Sch=je[8]                  \nset_property -dict { PACKAGE_PIN T17   IOSTANDARD LVCMOS33 } [get_ports { Pmod_out_0_pin9_io }]; #IO_L20P_T3_34 Sch=je[9]                     \nset_property -dict { PACKAGE_PIN Y17   IOSTANDARD LVCMOS33 } [get_ports { Pmod_out_0_pin10_io }]; #IO_L7N_T1_34 Sch=je[10]    \n</code></pre> Merci de remplacer <code>Pmod_out_0</code> par le nom du port de sortie du bloc IP PetaENC.</p>"},{"location":"docs/pmodenc_ip/#references","title":"R\u00e9f\u00e9rences","text":"<ul> <li>Pmod ENC</li> <li>R\u00e9pertoire IP PetaENC</li> <li>Biblioth\u00e8que Vivado de Digilent 2019.1</li> </ul>"},{"location":"docs/pmodenc_linux/","title":"Reprogrammation FPGA et application UIO pour PmodENC sous Linux","text":""},{"location":"docs/pmodenc_linux/#introduction","title":"Introduction","text":"<p>Ce projet vise \u00e0 r\u00e9cup\u00e9rer les donn\u00e9es du compteur de notre bloc IP personnalis\u00e9 via le driver UIO de Linux sur la carte Zybo Z7-20, en reprogrammant le FPGA. Le Zynq n'inclut pas initialement l'encodeur et son bloc IP dans le FPGA ni dans le Device Tree. Pour pallier cela, un Device Tree Overlay est utilis\u00e9, accompagn\u00e9 d'un nouveau bitstream \u00e0 impl\u00e9menter avec le FPGA Manager. Avoir Linux install\u00e9 sur la carte est un pr\u00e9requis. Vous pouvez suivre notre guide pour d\u00e9ployer Debian ou utiliser un autre RFS.</p> <p>Ce projet est disponible sur GitHub.</p>"},{"location":"docs/pmodenc_linux/#drivers","title":"Drivers","text":""},{"location":"docs/pmodenc_linux/#introduction_1","title":"Introduction","text":"<p>Pour faire fonctionner l'encodeur via UIO, il est n\u00e9cessaire de disposer du driver appropri\u00e9. Cela implique d'apporter quelques modifications initiales dans PetaLinux, puis de transf\u00e9rer les modules du kernel vers le RFS.</p> <p>Custom RFS</p> <p>Le RFS fourni par PetaLinux lors de la g\u00e9n\u00e9ration du projet contient d\u00e9j\u00e0 les drivers UIO. Cette partie ne s'applique que si vous utilisez un RFS autre que celui fourni par PetaLinux, comme vu dans notre guide. Cependant assurez-vous d'avoir les options de l'\u00e9tape 3 activ\u00e9es.</p>"},{"location":"docs/pmodenc_linux/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Projet PetaLinux avec son XSA</li> </ul> <p>Pour plus d'informations sur la g\u00e9n\u00e9ration du projet PetaLinux, veuillez consulter notre guide.</p>"},{"location":"docs/pmodenc_linux/#etapes","title":"\u00c9tapes","text":"<ol> <li> <p>Modifier la configuration PetaLinux pour conserver le dossier <code>linux-xlnx</code> contenant les diff\u00e9rents art\u00e9facts du kernel.</p> <ul> <li>Ajouter <code>RM_WORK_EXCLUDE += \"linux-xlnx\"</code> dans le fichier <code>petalinuxbsp.conf</code> disponible dans le dossier <code>project-spec/meta-user/conf/</code> du projet PetaLinux.</li> </ul> Les art\u00e9facts du kernel <p>Les artefacts du kernel sont les fichiers g\u00e9n\u00e9r\u00e9s lors de la compilation du noyau Linux, tels que les modules du kernel, les fichiers de configuration, et d'autres fichiers n\u00e9cessaires au bon fonctionnement du syst\u00e8me d'exploitation.</p> </li> <li> <p>Acc\u00e9der \u00e0 la configuration du kernel et activer les drivers UIO.</p> <pre><code>petalinux-config -c kernel\n</code></pre> <p>Veillez \u00e0 activer les options suivantes :</p> <ul> <li>Device Drivers -&gt; Userspace I/O drivers -&gt; Userspace I/O platform driver with generic IRQ handling</li> <li>Device Drivers -&gt; Userspace I/O drivers -&gt; Userspace platform driver with generic irq and dynamic memory </li> </ul> </li> <li> <p>Modifier les bootargs du kernel.</p> <pre><code>petalinux-config\n</code></pre> <ul> <li>DTG Settings -&gt; Kernel Bootargs -&gt; Add extra boot args : Ajouter <code>uio_pdrv_genirq.of_id=generic-uio</code>.</li> </ul> <p>TMPDIR emplacement</p> <p>Nous vous recommandons de noter le chemin du dossier temporaire cr\u00e9\u00e9 par PetaLinux, car il sera n\u00e9cessaire pour r\u00e9cup\u00e9rer les modules du kernel. Pour conna\u00eetre le chemin du dossier temporaire cr\u00e9\u00e9 par PetaLinux, allez dans :</p> <ul> <li>Yocto Settings -&gt; TMPDIR Location -&gt; TMPDIR Location</li> </ul> </li> <li> <p>Build le kernel. </p> <pre><code>petalinux-build -c kernel\n</code></pre> </li> <li> <p>Transf\u00e9rer le kernel vers la partition de BOOT de la carte SD.</p> <p>plus d'informations sur le transfert du kernel ici.</p> </li> <li> <p>Copier le dossier des modules du kernel dans le RFS.</p> <p>Acc\u00e9der au TMPDIR g\u00e9n\u00e9r\u00e9 par petalinux et se rendre dans le r\u00e9pertoire contenant les artefacts du kernel.</p> <pre><code>cd [TMPDIR]/work/zynq_generic_7z020-xilinx-linux-gnueabi/linux-xlnx/6.1.30-xilinx-v2023.2+gitAUTOINC+a19da02cf5-r0/image/lib/modules/\n</code></pre> <p>Copier le dossier <code>6.1.30-xilinx-v2023.2</code> dans le dossier <code>lib/modules</code> de votre RFS. Le nom du dossier peut varier en fonction de la version du kernel et de PetaLinux.</p> <p>Chemin des modules et nom du dossier</p> <p>Le chemin des modules et le nom du dossier peuvent varier en fonction de la version du kernel et de PetaLinux.</p> </li> <li> <p>F\u00e9licitations, les drivers UIO sont d\u00e9sormais disponibles dans votre RFS.</p> </li> </ol>"},{"location":"docs/pmodenc_linux/#bitstream","title":"Bitstream","text":""},{"location":"docs/pmodenc_linux/#introduction_2","title":"Introduction","text":"<p>Pour reprogrammer le FPGA, vous devez disposer d'un bitstream comprenant le block design utilis\u00e9 pr\u00e9c\u00e9demment pour g\u00e9n\u00e9rer le projet Petalinux, ainsi que les blocs IP et modules RTL que vous souhaitez ajouter. </p> <p>Dans le cadre de notre projet, le seul bloc IP ajout\u00e9 est PetaENC.</p>"},{"location":"docs/pmodenc_linux/#prerequis_1","title":"Pr\u00e9requis","text":"<p>La proc\u00e9dure d\u00e9crite ci-dessous suppose que :</p> <ol> <li>Le block design de base est celui r\u00e9cup\u00e9r\u00e9 lors de l'\u00e9tape G\u00e9n\u00e9ration du Mat\u00e9riel de notre guide Linux.</li> <li>Le bloc IP ajout\u00e9 est PetaENC disponible sur github.</li> </ol> <p>Pret \u00e0 l'emploi</p> <p>Si vous souhaitez utiliser le projet avec le block design final, vous pouvez le r\u00e9cup\u00e9rer sur github.</p>"},{"location":"docs/pmodenc_linux/#etapes_1","title":"\u00c9tapes","text":"<ol> <li> <p>Ouvrir le projet <code>hw_with_enc</code> dans Vivado, disponible en clonant le repository git.</p> </li> <li> <p>S'assurer que le bloc IP personnalis\u00e9 est bien dans le catalogue, voir Ajout du Bloc IP \u00e0 Vivado pour plus d'informations.</p> </li> <li> <p>R\u00e9aliser la synth\u00e8se, l'impl\u00e9mentation et la g\u00e9n\u00e9ration du bitstream.</p> </li> <li> <p>Exporter le bitstream en faisant clic-droit sur l'impl\u00e9mentation dans la section <code>Project Manager &gt; Design Runs</code> puis <code>Export Bitstream File...</code>.</p> </li> <li> <p>Suivre les indications de la section G\u00e9n\u00e9ration d'un Fichier BIN \u00e0 partir d'un Fichier BIT de la documention sur le FPGA Manager afin de transformer le BIT en BIN.</p> </li> <li> <p>Transf\u00e9rer le BIN sur l'envirronement linux de la Zybo.</p> </li> <li> <p>F\u00e9licitations, le bitstream est pr\u00eat \u00e0 \u00eatre utilis\u00e9 pour reprogrammer le FPGA.</p> </li> </ol>"},{"location":"docs/pmodenc_linux/#overlay","title":"Overlay","text":""},{"location":"docs/pmodenc_linux/#introduction_3","title":"Introduction","text":"<p>Tout comme le bitstream est n\u00e9cessaire pour reprogrammer le FPGA, le Device Tree Overlay est n\u00e9cessaire afin que le kernel Linux puisse interagir avec notre bloc IP personnalis\u00e9.</p> <p>Le DTO utilis\u00e9 ici est sp\u00e9cifique \u00e0 notre bloc IP et est expliqu\u00e9 plus en d\u00e9tail dans la section Exemple DTO pour un encodeur dans la documentation sur les DT.</p>"},{"location":"docs/pmodenc_linux/#prerequis_2","title":"Pr\u00e9requis","text":"<ul> <li>Fichier source <code>.dtso</code> du DTO, disponible sur github du projet.</li> <li>Device Tree Compiler (DTC) pour compiler le DTO. Disponible dans vitis (<code>Vitis/2023.1/bin/</code> pour la versin 2023.1) ou depuis le repository officiel</li> </ul>"},{"location":"docs/pmodenc_linux/#etapes_2","title":"\u00c9tapes","text":"<p>Correspondance des noms</p> <p>Assurez-vous que le nom du fichier <code>.bit.bin</code> g\u00e9n\u00e9r\u00e9 dans la section pr\u00e9c\u00e9dente correspond \u00e0 celui utilis\u00e9 dans le DTO. Veillez modifier le DTO si n\u00e9cessaire.</p> <ol> <li> <p>Suivre la proc\u00e9dure de compilation d'un DTO.</p> </li> <li> <p>Transf\u00e9rer le <code>.dtbo</code> r\u00e9sultant sur l'environnement linux de la Zybo.</p> </li> <li> <p>F\u00e9licitations, le DTO est pr\u00eat \u00e0 \u00eatre utilis\u00e9 pour reprogrammer le FPGA.</p> </li> </ol>"},{"location":"docs/pmodenc_linux/#application","title":"Application","text":""},{"location":"docs/pmodenc_linux/#introduction_4","title":"Introduction","text":"<p>Une fois que les drivers, le bitstream au format BIN, et le DTO compil\u00e9 sont disponibles sur la Zybo, la reprogrammation du FPGA peut \u00eatre effectu\u00e9e. Cependant, il est \u00e9galement n\u00e9cessaire de disposer d'une application pour tester le bon fonctionnement de notre encodeur. Une application simple utilisant le driver UIO est disponible dans le dossier <code>app</code> du repository git de notre projet.</p> <p>Cette application doit \u00eatre compil\u00e9e pour l'architecture cible, en l'occurrence armhf. Il est donc n\u00e9cessaire d'utiliser un cross-compiler pour effectuer cette compilation.</p>"},{"location":"docs/pmodenc_linux/#prerequis_3","title":"Pr\u00e9requis","text":"<ul> <li>Fichier <code>.c</code> de l'application <code>check_uio_value</code>, disponible dans <code>app</code> dans notre repository git.</li> <li>Cross-compiler GCC armhf, tel que celui disponible sur le site officiel de d\u00e9veloppement ARM, assurez-vous de t\u00e9l\u00e9charger une version ciblant Arch32 GNU/Linux avec hard float (arm-none-linux-gnueabihf).</li> </ul>"},{"location":"docs/pmodenc_linux/#etapes_3","title":"\u00c9tapes","text":"<ol> <li> <p>Compiler l'application <code>check_uio_value</code> avec cross-compiler GCC</p> <pre><code>arm-none-linux-gnueabihf-gcc -o check_uio_value check_uio_value.c\n</code></pre> </li> <li> <p>Transf\u00e9rer l'application r\u00e9sultante sur l'environnement linux de la Zybo.</p> </li> <li> <p>La rendre \u00e9xecutable avec <code>chmod +x check_uio_value</code>.</p> </li> <li> <p>F\u00e9licitations, vous avez d\u00e9sormais tout les \u00e9l\u00e9ments n\u00e9cessaires pour reprogrammer le FPGA et tester l'encodeur.</p> </li> </ol>"},{"location":"docs/pmodenc_linux/#reprogrammation-et-test-de-lencodeur","title":"Reprogrammation et test de l'encodeur","text":""},{"location":"docs/pmodenc_linux/#introduction_5","title":"Introduction","text":"<p>Tous les \u00e9lements n\u00e9cessaires sont d\u00e9sormais r\u00e9unis, il ne manque plus qu'\u00e0 r\u00e9aliser la reprogrammation et tester l'encodeur avec l'application pr\u00e9c\u00e9demment compil\u00e9e.</p>"},{"location":"docs/pmodenc_linux/#prerequis_4","title":"Pr\u00e9requis","text":"<ul> <li>Drivers UIO</li> <li>Bitstream BIN</li> <li>DTO compil\u00e9</li> <li>Application compil\u00e9</li> </ul>"},{"location":"docs/pmodenc_linux/#etapes_4","title":"\u00c9tapes","text":"<ol> <li> <p>Suivre les \u00e9tapes de reprogrammation <code>Avec DTO</code> de la section Mise \u00e0 Jour du FPGA depuis Linux de notre guide FPGA Manager.</p> </li> <li> <p>Une fois la reprogrammation r\u00e9alis\u00e9e, brancher l'encodeur dans le connecteur JE de la carte Zybo Z7-20.</p> </li> <li> <p>Lancer l'application <code>check_uio_value</code> avec la commande <code>check_uio_value 0 0x0 0x1000 polling</code>.</p> <ul> <li>La premi\u00e8re valeur <code>0</code> repr\u00e9sente le num\u00e9ro de device UIO visible dans <code>/dev/</code>, donc ici <code>/dev/uio0</code>.</li> <li>La deuxi\u00e8me valeur repr\u00e9sente l'offset de l'adresse \u00e0 check, ici <code>0x0</code> \u00e9tant donn\u00e9 que c'est le registre 0 de notre bloc IP \u00e0 v\u00e9rifier.</li> <li>La troisi\u00e8me valeur repr\u00e9sente la taille de la m\u00e9moire allou\u00e9e au device, donc ici <code>0x1000</code>.</li> <li>L'option <code>polling</code> permet d'afficher \u00e0 l'\u00e9cran la valeur du registre toutes les secondes.</li> </ul> </li> <li> <p>Tourner l'encodeur et voir la valeur du compteur augmenter. Vous pouvez appuyer sur l'encodeur pour remettre le codeur \u00e0 0.</p> </li> <li> <p>Faire Ctrl+C pour quitter l'application.</p> </li> </ol>"},{"location":"docs/pmodenc_vhdl/","title":"Projet VHDL : Contr\u00f4le de Compteur avec Encodeur Rotatif PMODENC et Affichage LED","text":""},{"location":"docs/pmodenc_vhdl/#introduction","title":"Introduction","text":"<p>Ce projet d\u00e9montre comment concevoir un syst\u00e8me bas\u00e9 sur VHDL en utilisant Xilinx Vivado pour contr\u00f4ler un compteur avec l'encodeur rotatif Digilent PmodENC. La valeur du compteur est affich\u00e9e sur 4 LEDs de la carte FPGA Zybo Z7-20.</p> <p>Ce projet s'inspire du guide Nexys 3 VHDL Example - ISE 14.2 de Digilent.</p>"},{"location":"docs/pmodenc_vhdl/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Xilinx Vivado Design Suite</li> <li>Carte FPGA Zybo Z7-20</li> <li>Encodeur rotatif Digilent PmodENC</li> </ul>"},{"location":"docs/pmodenc_vhdl/#code-vhdl","title":"Code vhdl","text":"<p>Le projet utilise trois fichiers VHDL : pmodenc.vhd, encoder.vhd et debouncer.vhd. Ces fichiers d\u00e9finissent la logique de l'encodeur rotatif, le compteur et le d\u00e9compteur, ainsi que la stabilisation des signaux d'entr\u00e9e.</p> Code VHDL : <code>pmodenc.vhd</code> <p>Ce fichier contient l'entit\u00e9 principale qui connecte le d\u00e9compteur et l'encodeur.</p> <pre><code>library IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\n\nentity PmodENC is\n    Port (\n        clk: in std_logic;\n        pmod : in STD_LOGIC_VECTOR (3 downto 0);\n        leds: inout STD_LOGIC_VECTOR (3 downto 0)\n    );\nend PmodENC;\n\narchitecture Behavioral of PmodENC is\n    signal AO, BO: std_logic;\n\n    begin\n        C0: entity work.Debouncer port map ( \n                clk=&gt;clk,\n                Ain=&gt;pmod(0),\n                Bin=&gt;pmod(1),\n                Aout=&gt; AO,\n                Bout=&gt; BO\n            );\n\n        C1: entity work.Encoder port map ( \n                clk=&gt;clk,\n                A=&gt;AO,\n                B=&gt;BO,\n                BTN=&gt;pmod(2),\n                LED=&gt;leds\n            );\nend Behavioral;\n</code></pre> Code VHDL : <code>encoder.vhd</code> <p>Ce fichier g\u00e8re l'\u00e9tat de l'encodeur rotatif et met \u00e0 jour les LEDs en fonction des mouvements.</p> <pre><code>library IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Encoder is\n    Port (\n        clk: in STD_LOGIC;\n        -- signals from the pmod\n        A : in  STD_LOGIC;  \n        B : in  STD_LOGIC;\n        BTN : in  STD_LOGIC;\n        -- position of the shaft\n        LED: inout STD_LOGIC_VECTOR (3 downto 0)\n      );\nend Encoder;\n\narchitecture Behavioral of Encoder is\n    type stateType is ( idle, R1, R2, R3, L1, L2, L3, add, sub);\n    signal curState, nextState: stateType;\nbegin\n    clock: process (clk, BTN)\n    begin\n        if (BTN='1') then\n            curState &lt;= idle;\n            LED &lt;= \"0000\";\n        elsif (clk'event and clk = '1') then\n            if curState /= nextState then\n                if (curState = add) then\n                    if LED &lt; \"1111\" then \n                        LED &lt;= LED+1;\n                    else\n                        LED &lt;= \"0000\";\n                    end if;\n                elsif (curState = sub) then\n                    if LED &gt; \"0000\" then \n                        LED &lt;= LED-1;\n                    else\n                        LED &lt;= \"1111\";\n                    end if;\n                else\n                    LED &lt;= LED;\n                end if;\n            else\n                LED &lt;= LED;\n            end if;\n            curState &lt;= nextState;\n        end if;\n    end process; \n\n    next_state: process (curState, A, B)\n\n    begin\n        case curState is\n            when idle =&gt;\n                if B = '0' then\n                    nextState &lt;= R1;\n                elsif A = '0' then\n                    nextState &lt;= L1;\n                else\n                    nextState &lt;= idle;\n                end if;\n            -- start of right cycle\n            --R1\n            when R1 =&gt;\n                if B='1' then\n                    nextState &lt;= idle;\n                elsif A = '0' then\n                    nextState &lt;= R2;\n                else\n                    nextState &lt;= R1;\n                end if;\n            --R2                    \n            when R2 =&gt;              \n                if A ='1' then\n                    nextState &lt;= R1;\n                elsif B = '1' then\n                    nextState &lt;= R3;\n                else\n                    nextState &lt;= R2;\n               end if;\n            --R3    \n            when R3 =&gt;\n                if B ='0' then\n                    nextState &lt;= R2;\n                elsif A = '1' then\n                    nextState &lt;= add;\n                else\n                    nextState &lt;= R3;\n                end if;\n            when add =&gt; \n                nextState &lt;= idle;\n            -- start of left cycle\n            --L1 \n            when L1 =&gt;\n                if A ='1' then\n                    nextState &lt;= idle;\n                elsif B = '0' then\n                    nextState &lt;= L2;\n                else\n                    nextState &lt;= L1;\n                end if;\n            --L2    \n            when L2 =&gt;\n                if B ='1' then\n                   nextState &lt;= L1;\n                elsif A = '1' then\n                    nextState &lt;= L3;\n                else\n                    nextState &lt;= L2;\n                end if;\n            --L3\n            when L3 =&gt;\n                if A ='0' then\n                    nextState &lt;= L2;\n                elsif B = '1' then\n                    nextState &lt;= sub;\n                else\n                    nextState &lt;= L3;\n                end if;\n            when sub =&gt; \n                nextState &lt;= idle;\n            when others =&gt;\n                nextState &lt;= idle;\n        end case;\n    end process;    \n\nend Behavioral;\n</code></pre> Code VHDL : <code>debouncer.vhd</code> <p>Ce fichier filtre les signaux d'entr\u00e9e pour \u00e9liminer les rebonds (bruit) et fournit des signaux stables \u00e0 l'encodeur.</p> <pre><code>library IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\n\nentity Debouncer is\n    Port ( \n        clk : in  STD_LOGIC;\n        Ain : in  STD_LOGIC; \n        Bin : in  STD_LOGIC;\n        Aout: out STD_LOGIC;\n        Bout: out STD_LOGIC\n    );\nend Debouncer;\n\narchitecture Behavioral of Debouncer is\n\nsignal sclk: std_logic_vector (6 downto 0);\nsignal sampledA, sampledB : std_logic;\nbegin\n\n    process(clk)\n        begin \n            if clk'event and clk = '1' then\n                sampledA &lt;= Ain;\n                sampledB &lt;= Bin;\n                -- clock is divided to 1MHz\n                -- samples every 1uS to check if the input is the same as the sample\n                -- if the signal is stable, the debouncer should output the signal\n                if sclk = \"1100100\" then\n                    if sampledA = Ain then \n                        Aout &lt;= Ain;\n                    end if;\n                    if sampledB = Bin then \n                        Bout &lt;= Bin;\n                    end if;\n                    sclk &lt;=\"0000000\";\n                else\n                    sclk &lt;= sclk +1;\n                end if;\n            end if;\n    end process;\n\nend Behavioral;\n</code></pre>"},{"location":"docs/pmodenc_vhdl/#configuration-materielle","title":"Configuration mat\u00e9rielle","text":"Contraintes XDC <p>Les contraintes XDC sont utilis\u00e9es pour mapper les signaux du projet VHDL aux broches physiques de la carte FPGA.</p> <pre><code>create_clock -period 100.000 -name clk [get_ports clk]\nset_property PACKAGE_PIN K17 [get_ports clk]\nset_property IOSTANDARD LVCMOS33 [get_ports clk]\n\n## LEDs\nset_property -dict { PACKAGE_PIN M14   IOSTANDARD LVCMOS33 } [get_ports {leds[0]}]\nset_property -dict { PACKAGE_PIN M15   IOSTANDARD LVCMOS33 } [get_ports {leds[1]}]\nset_property -dict { PACKAGE_PIN G14   IOSTANDARD LVCMOS33 } [get_ports {leds[2]}]\nset_property -dict { PACKAGE_PIN D18   IOSTANDARD LVCMOS33 } [get_ports {leds[3]}]\n\n## JE\nset_property PACKAGE_PIN V12      [get_ports {pmod[0]}]                 \nset_property IOSTANDARD LVCMOS33 [get_ports {pmod[0]}]\nset_property PACKAGE_PIN W16      [get_ports {pmod[1]}]                 \nset_property IOSTANDARD LVCMOS33 [get_ports {pmod[1]}]\nset_property PACKAGE_PIN J15      [get_ports {pmod[2]}]                 \nset_property IOSTANDARD LVCMOS33 [get_ports {pmod[2]}]\nset_property PACKAGE_PIN H15      [get_ports {pmod[3]}]                 \nset_property IOSTANDARD LVCMOS33 [get_ports {pmod[3]}]\n</code></pre>"},{"location":"docs/pmodenc_vhdl/#broches-du-connecteur-pmod-je-pour-le-pmodenc","title":"Broches du connecteur PMOD JE pour le PMODENC","text":"<p>Nous avons utilis\u00e9 les broches du connecteur PMOD JE pour connecter l'encodeur rotatif PMODENC \u00e0 la carte Zybo Z7-20. Voici la configuration mat\u00e9rielle utilis\u00e9e pour ce projet :</p> Signal Pin A V12 B W16 BTN J15 SWT H15"},{"location":"docs/pmodenc_vhdl/#horloge","title":"Horloge","text":"Signal Pin Description clk K17 sysclk du Zybo <p>Pour plus d'informations sur les ports du Zybo Z7-20, consultez la documentation officielle.</p>"},{"location":"docs/pmodenc_vhdl/#utilisation-du-projet","title":"Utilisation du Projet","text":""},{"location":"docs/pmodenc_vhdl/#ouverture-du-projet-dans-vivado","title":"Ouverture du Projet dans Vivado","text":"<ol> <li> <p>Lancer Vivado:</p> <ul> <li>Ouvrez Xilinx Vivado Design Suite sur votre ordinateur.</li> </ul> </li> <li> <p>Ouvrir le Projet Existant:</p> <ul> <li>Allez dans <code>File &gt; Open Project</code>.</li> <li>Naviguez vers le r\u00e9pertoire du repository et s\u00e9lectionnez le fichier de projet <code>ENC_demo.xpr</code> pour l'ouvrir.</li> </ul> </li> </ol>"},{"location":"docs/pmodenc_vhdl/#construction-du-projet","title":"Construction du Projet","text":"<ol> <li>G\u00e9n\u00e9rer le Bitstream:<ul> <li>Cliquez sur <code>Generate Bitstream</code> pour compiler votre design en un fichier binaire ex\u00e9cutable sur la FPGA.</li> </ul> </li> </ol>"},{"location":"docs/pmodenc_vhdl/#programmation-de-la-fpga","title":"Programmation de la FPGA","text":"<ol> <li> <p>Connecter la Carte FPGA:</p> <ul> <li>Connectez la carte Zybo Z7-20 \u00e0 votre ordinateur en utilisant un c\u00e2ble USB.</li> </ul> </li> <li> <p>Programmer le Dispositif:</p> <ul> <li>Dans Vivado, allez dans <code>Open Hardware Manager</code> et cliquez sur <code>Open Target &gt; Auto Connect</code>.</li> <li>Cliquez sur <code>Program Device</code> et s\u00e9lectionnez le fichier bitstream g\u00e9n\u00e9r\u00e9 pour programmer la FPGA.</li> </ul> </li> </ol>"},{"location":"docs/pmodenc_vhdl/#execution-de-lapplication","title":"Ex\u00e9cution de l'Application","text":"<ol> <li> <p>Connecter le PMODENC:</p> <ul> <li>Attachez l'encodeur rotatif PMODENC au connecteur PMOD appropri\u00e9 sur la carte Zybo Z7-20.</li> </ul> </li> <li> <p>Observer l'Affichage LED:</p> <ul> <li>Tournez l'encodeur rotatif PMODENC.</li> <li>La valeur du compteur sera affich\u00e9e sur les 4 LEDs de la carte Zybo Z7-20.</li> </ul> </li> </ol>"},{"location":"docs/ssh_activation/","title":"Comment activer SSH","text":""},{"location":"docs/ssh_activation/#introduction","title":"Introduction","text":"<p>Le protocole SSH est un protocole de communication s\u00e9curis\u00e9 permettant d'acc\u00e9der \u00e0 distance \u00e0 un syst\u00e8me. Ce guide vous explique comment activer et configurer SSH sur une carte embarqu\u00e9e sous Debian.</p>"},{"location":"docs/ssh_activation/#configuration-dune-ip-statique-optionnel","title":"Configuration d'une IP statique (optionnel)","text":"<p>Pour faciliter la connexion SSH, il peut \u00eatre utile de configurer une IP statique. Suivez les \u00e9tapes ci-dessous pour d\u00e9finir une IP statique sur votre carte.</p> <ol> <li> <p>\u00c9ditez le fichier de configuration r\u00e9seau :</p> <pre><code>sudo vim /etc/network/interfaces.d/ssh_static.conf\n</code></pre> <p>Ajoutez les lignes suivantes :</p> <pre><code>auto enp0\niface enp0 inet static\n    address 192.168.0.50\n    netmask 255.255.255.0\n    gateway 192.168.0.1\n</code></pre> <p>Remplacez <code>enp0</code> par le nom de votre interface r\u00e9seau si n\u00e9cessaire.</p> </li> <li> <p>Red\u00e9marrez le service r\u00e9seau :</p> <pre><code>sudo systemctl restart networking\n</code></pre> </li> <li> <p>V\u00e9rifiez la configuration r\u00e9seau :</p> <pre><code>ifconfig\n</code></pre> <p>Assurez-vous que l'adresse IP statique est correctement assign\u00e9e.</p> </li> <li> <p>Configurez votre PC avec une adresse IP dans le m\u00eame sous-r\u00e9seau :</p> <p>Assignez \u00e0 votre PC une adresse IP comme <code>192.168.0.x</code>, o\u00f9 <code>x</code> est un nombre diff\u00e9rent de 50.</p> </li> <li> <p>Testez la connexion en pingant l'adresse IP :</p> <pre><code>ping 192.168.0.50\n</code></pre> <p>Si vous recevez une r\u00e9ponse, cela signifie que la configuration r\u00e9seau est correcte.</p> </li> </ol>"},{"location":"docs/ssh_activation/#configuration-ssh","title":"Configuration SSH","text":"<ol> <li> <p>\u00c9ditez le fichier de configuration SSH :</p> <pre><code>sudo vim /etc/ssh/sshd_config.d/local.conf\n</code></pre> <p>Ajoutez les lignes suivantes :</p> <pre><code>Port 22\nAddressFamily inet\nListenAddress 192.168.0.50\n</code></pre> <p>Cela configure le service SSH pour \u00e9couter sur le port 22 et l'adresse IP 192.168.0.50.</p> </li> <li> <p>Red\u00e9marrez le service SSH :</p> <pre><code>sudo systemctl restart sshd\n</code></pre> </li> <li> <p>V\u00e9rifiez l'\u00e9tat du service SSH :</p> <pre><code>sudo systemctl status sshd\n</code></pre> <p>Assurez-vous que le service SSH est actif et en cours d'ex\u00e9cution.</p> </li> <li> <p>Testez la connexion SSH depuis votre PC :</p> <pre><code>ssh debian@192.168.0.50\n</code></pre> <p>Remplacez <code>debian</code> par votre nom d'utilisateur sur la carte embarqu\u00e9e. Si la connexion est r\u00e9ussie, vous avez activ\u00e9 SSH avec succ\u00e8s.</p> </li> </ol>"},{"location":"journal/semaine1/","title":"Semaine 1","text":""},{"location":"journal/semaine1/#mardi-1405","title":"Mardi 14/05","text":"<p>RDV initial avec prof d\u00e9plac\u00e9, recherche et documentation initiale, trois pistes possibles : petalinux, yocto, manuel. On a majoritairement fait du manuel cette journ\u00e9e-l\u00e0 \u00e0 build manuellement les projets git xilinx, mauvaise id\u00e9e + certains \u00e9l\u00e9ments ne correspondent pas \u00e0 notre zybo mais au zc702 (vu seulement la journ\u00e9e d'apr\u00e8s)...</p>"},{"location":"journal/semaine1/#mercredi-1505","title":"Mercredi 15/05","text":"<p>RDV avec le prof, but : distro linux classique sur la zybo + programmer dynamiquement le fpga, tout \u00e7a sur carte sd pour le moment. Petalinux OK (heureusement). Prise en main de l'outil initial puis on remarque qu'on utilisait des \u00e9l\u00e9ments comme le Device Tree de la ZC702... Donc direction le site digilent zybo z7-20 pour des d\u00e9mos -&gt; aucune \u00e0 jour pour petalinux 2023.2 (derni\u00e8re version 2022.1). DONC t\u00e9l\u00e9chargement du repo github de la d\u00e9mo Petalinux 2022.1 afin de choper le block diagram et mettre \u00e0 jour les blocs IP sur vivado (fait auto par vivado d'ailleurs). Export du XSA correspondant \u00e0 la d\u00e9mo avec ses quelques fonctionnalit\u00e9s.</p>"},{"location":"journal/semaine1/#jeudi-1605","title":"Jeudi 16/05","text":"<p>Import du xsa dans petalinux puis d\u00e9but de config -&gt; activer carte sd, formater bien la carte sd, etc. Build r\u00e9alis\u00e9 aussi et t\u00e9l\u00e9chargement du rootfs puis transfert du tout sur la carte sd. Test sur la zybo et ... \u00e9chec. FSBL/U-Boot fonctionnent nickel mais le kernel n'arrive pas \u00e0 boot le rootfs et reste plant\u00e9 sur \"bootconsole cdns0 disabled\" Possible moyen de r\u00e9soudre le pb trouv\u00e9 : ro est pass\u00e9 dans les command line parameters du kernel \u00e0 cause d'un bug de petalinux 2023.2</p>"},{"location":"journal/semaine1/#vendredi-1705","title":"Vendredi 17/05","text":"<p>rw rajout\u00e9 dans la config afin que le rootfs soit bien pris en read-write pour fix le bug d'avant mais le probl\u00e8me du bootconsole est toujours pr\u00e9sent Activation des options debug afin d'y voir plus clair... Pas grand chose de trouv\u00e9... Jusqu'\u00e0 qu'on remarque que le FPGA Manager n'est PAS activ\u00e9, une fois activ\u00e9 tout marche ! Visiblement deux trois petits pb \u00e0 r\u00e9soudre dans le lancement de debian mais on arrive bien \u00e0 un terminal et on peut commencer \u00e0 s'amuser</p>"},{"location":"journal/semaine2/","title":"Semaine 2","text":""},{"location":"journal/semaine2/#mardi-2105","title":"Mardi 21/05","text":"<p>Ajout d'un premier jet de documentation avec un onglet \"Documentation\" et \"Journal de bord\" dans le menu de navigation. Test de la proc\u00e9dure Linux avec PetaLinux sur la seconde carte Zybo. Quelques modifications \u00e0 apporter puis succ\u00e8s de la proc\u00e9dure (ACL, BinFS, AutoFS, ...) Demande effectu\u00e9e pour obtenir les encodeurs.</p>"},{"location":"journal/semaine2/#mercredi-2205","title":"Mercredi 22/05","text":"<p>Recherche et documentation sur encodeurs incr\u00e9mentaux pour la carte Zybo Z7-20. Comprehenion du fonctionnement du device tree Overlay + Possibilit\u00e9 de changer les param\u00e8tres du FPGA dpeuis Linux.</p>"},{"location":"journal/semaine2/#jeudi-2305","title":"Jeudi 23/05","text":"<p>R\u00e9alisation projet VHDL pour l'encodeur incr\u00e9mental avec debuncer. Test de l'encodeur incr\u00e9mental sur les cartes Zybo Z7-20. Ajustement de la documentation en ligne. Activation du SSH sur la carte Zybo Z7-20. G\u00e9n\u00e9rations du fichier bin + load le fichier sur le FPGA. A faire, utilisation d'un overlay car fpga_manager bloque l'utilisation de linux.</p>"},{"location":"journal/semaine3/","title":"Semaine 3","text":"<p>Dwayne sera absent cette semaine en raison d'une formation.</p> <p>C'est une semaine de repos avec quelques pr\u00e9parations.</p>"},{"location":"journal/semaine4/","title":"Semaine 4","text":""},{"location":"journal/semaine4/#lundi-0306","title":"Lundi 03/06","text":"<p>Discussion \u00e0 propos de la direction \u00e0 prendre et des \u00e9l\u00e9ments \u00e0 d\u00e9velopper (overlay, tests drivers).</p> <p>Premiers essais avec Vitis, incluant la cr\u00e9ation d'une plateforme et d'un projet en C. Recherche sur l'installation du driver Pmod_ENC et tentative de compilation du device tree.</p>"},{"location":"journal/semaine4/#mardi-0406","title":"Mardi 04/06","text":"<p>Nous avons remarqu\u00e9 que les drivers Digilent fournis ne sont pas des LKM (Linux Kernel Modules), ce sont des drivers baremetal. D\u00e9cision prise sur le d\u00e9veloppement d'un bloc IP custom afin de bien montrer le reprogrammation PL avec le FPGA manager et de faire un driver custom LKM.</p> <p>D\u00e9veloppement bloc IP custom, reprise du VHDL r\u00e9alis\u00e9 plus t\u00f4t afin de le mettre en module RTL dans le bloc avec ajout d'un bloc Xilinx AXI GPIO et Digilent Pmod Bridge. Modification du VHDL pour utiliser numeric_std, plus r\u00e9cent et de plus en plus utilis\u00e9 d\u00e9sormais.</p> <p>Documentation sur la g\u00e9n\u00e9ration d'un device tree et de la r\u00e9alisation d'un projet baremetal en C avec vitis.</p>"},{"location":"journal/semaine4/#mercredi-0506","title":"Mercredi 05/06","text":"<p>R\u00e9alisation de l'overlay en se basant sur le xsa de base et le xsa avec notre bloc IP en plus.</p> <p>Abandon du d\u00e9veloppement d'un driver LKM custom, trop compliqu\u00e9 \u00e0 faire m\u00eame si toutefois int\u00e9ressant. Driver/programme c\u00f4t\u00e9 userspace (type /dev/mem/ ou UIO) OU utilisation du driver GPIO existant envisag\u00e9s.</p>"},{"location":"journal/semaine4/#jeudi-0606","title":"Jeudi 06/06","text":"<p>Oleg part sur l'UIO, Dwayne sur le driver GPIO. </p> <p>Modification de l'overlay pour pointer vers le driver UIO g\u00e9n\u00e9rique (generic-uio) et reprog du FPGA avec le FPGA Manager. </p> <p>Toutefois, device UIO introuvable dans \"/dev/\"... Tentative de lier generic-uio au driver uio_pdrv_genirq dans les rootargs, ne marche pas. El\u00e9ments manquants dans la config petalinux, on reconfigure mais ne marche toujours pas... En r\u00e9alit\u00e9, nous avons oubli\u00e9 de transf\u00e9rer les drivers fournis par petalinux (qui sont packaged dans son rootfs en tant que modules et non le kernel), donc transfert des modules vers notre rootfs Debian.</p> <p>Tout cela nous am\u00e8ne bien \u00e0 la d\u00e9tection du device UIO une fois la reprog FPGA r\u00e9alis\u00e9e, mais l'encodeur ne marche malheureusement pas.</p>"},{"location":"journal/semaine4/#vendredi-0706","title":"Vendredi 07/06","text":"<p>Tentative de r\u00e9soudre le probl\u00e8me SANS r\u00e9aliser de simulation de notre bloc IP custom, aucun r\u00e9sultat.</p>"},{"location":"journal/semaine5/","title":"Semaine 5","text":""},{"location":"journal/semaine5/#lundi-1006","title":"Lundi 10/06","text":"<p>D\u00e9cision prise de debug le bloc IP custom en passant par des simulations : abandon de l'utilisation du mode buffer en faveur du mode inout (recommendation officielle de Xilinx de toute fa\u00e7on).</p>"},{"location":"journal/semaine5/#mardi-1106","title":"Mardi 11/06","text":"<p>Debug du bloc IP custom : registres tristate du Pmod Bridge non-configur\u00e9s en input donc ajout d'un bloc Constant pour le faire, encore quelques fix niveau switch buffer/inout et sur numeric_std pour les conversions UNSIGNED en STD_LOGIC_VECTOR.</p> <p>D\u00e9veloppement d'une appli de test plus pratique c\u00f4t\u00e9 Linux, check direct d'une adresse d'un device UIO avec polling toutes les secondes en option.</p> <p>Encodeur fonctionnel et continuit\u00e9 des op\u00e9rations niveau Linux assur\u00e9e.</p>"},{"location":"journal/semaine5/#mercredi-1206","title":"Mercredi 12/06","text":"<p>Discussion projet, avanc\u00e9es mineures</p>"},{"location":"journal/semaine5/#jeudi-1306","title":"Jeudi 13/06","text":"<p>Nous avons pr\u00e9sent\u00e9 le projet \u00e0 M. Thieblot et discut\u00e9 de la continuation du TER. Quelques points restent \u00e0 traiter :   - Overlays avec interruption   - Adresse MAC fixe   - Finalisation de la documentation</p>"},{"location":"journal/semaine5/#vendredi-1406","title":"Vendredi 14/06","text":"<p>Mise \u00e0 jour des descriptions et des fichiers README sur GitHub pour tous les projets. Ajout d'une branche pour les projets Vivado compatibles avec la version 2023.2, car les projets ont \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9s avec la version 2023.1 (version disponible sur les machines de la salle 305).</p>"},{"location":"journal/semaine6/","title":"Semaine 6","text":""},{"location":"journal/semaine6/#lundi-1706","title":"Lundi 17/06","text":"<p>Mise a jour de la documentation. <pre><code>Documentation                             --\n    S\u00e9quence de boot                      OK\n    Les Devices Tree                      IN PROGRESS\n    FPGA Manager                          OK\n    Projets                               --\n        Linux - Zybo z7-20                OK\n        PmodENC - VHDL personnalis\u00e9       OK\n        PmodENC - Baremetal application   OK\n        PmodENC - Bloc IP personnalis\u00e9    OK\n        WIP PmodENC - Linux application   TODO\n    Rappels                               --\n        Activation SSH                    OK\n</code></pre></p>"},{"location":"journal/semaine6/#mardi-1806","title":"Mardi 18/06","text":"<p>Mise a jour de la documentation. <pre><code>Documentation                             --\n    Les Devices Tree                      OK\n    Projets                               --\n        WIP PmodENC - Linux application   WIP\n</code></pre></p>"},{"location":"journal/semaine6/#mercredi-1906","title":"Mercredi 19/06","text":"<ul> <li>Finalisation de la documentation. YEY ! <pre><code>Documentation                             --\n    Projets                               --\n        PmodENC - Linux application       OK\n</code></pre></li> <li>Address MAC : OK</li> <li>projet vivado PmodENC_Linux mis \u00e0 jour pour vivado 2023.2</li> <li>fix bug l'ip PetaENC version 2023.2</li> <li>test de l'ensemble des documentations depuis le d\u00e9but pour trouver des erreurs ou des oublis</li> </ul>"},{"location":"journal/semaine6/#jeudi-2006","title":"Jeudi 20/06","text":"<p>L'application avec les interruptions est d\u00e9sormais termin\u00e9e et tous les objectifs de base sont d\u00e9sormais atteints. Envoi d'un mail pour informer le prof des diff\u00e9rents repos et r\u00e9alisations.</p>"},{"location":"journal/semaine6/#vendredi-2106","title":"Vendredi 21/06","text":"<p>R\u00e9ception de l'avis du prof qui est satisfait, il ne reste plus que le rapport et la soutenance \u00e0 pr\u00e9parer au niveau des attentes de l'UE, le reste est du bonus.</p>"}]}